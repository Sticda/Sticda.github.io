{"meta":{"title":"Sticda","subtitle":null,"description":null,"author":"Sticda","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"markdown语法","slug":"markdown语法","date":"2018-03-22T08:18:03.915Z","updated":"2017-12-22T06:34:22.116Z","comments":true,"path":"2018/03/22/markdown语法/","link":"","permalink":"http://yoursite.com/2018/03/22/markdown语法/","excerpt":"","text":"标题是这样的还可以是这样标题后面加任意数量的“-”或者“=”，两种表示方式后面的-和=是随意的，1到无穷大，但后面的数量和标题的级别没关系。 一级标题二级标题三级标题四级标题一定数量的#加标题，以此类推，无穷矣。 区块引用，目前还没看出来这种引用有什么用途，唯一需要做的就是在某段文字的最前面加上&gt;,或者在这段文字的每一行前面加上&gt;.引用中层次的不同只需要改变前面的&gt;的数量 二级引用，引用中的引用，你值得拥有。（改这一行前面的&gt;的数量） 就是这么神奇。。。。。 无序列表的使用就是在每一项的前面加上一个*、+、- 效果都是一样的，而且可以混用 但是一般情况还是统一用一种，看起来比较整齐。 ￥￥￥￥￥￥ 有序列表就很简单了，但也很扎心 直接在某项前面加上数字和点 扎心的地方在于如果直接跟在无序列表后面的话，有序的这部分就会直接无序，所以我用了六个人民币符号隔开了。 代码区块就是行首缩进一个制表符，Class.forName(“xxxx”); 就是这样 上面的就是分隔线，三个以上的“”和“-”“就可以出现这种效果 ，这几个“-”和“ \\ ”可以用空格隔开，也可以不需要 超链接的用法这是一个超链接的示意,主要的用法就是把需要超链接的部分用方括号[]括起来，后面紧跟圆括号，圆括号里面是超链接的地址 [baidu][hhh]第二种用法是这样的，方括号括起来的文字后面紧跟方括号括起来的id，随便id是什么，然后在文章的任意一个部分加上[id]:具体链接，这样就可以了，[hhh]: http:www.baidu.com 一句话前后各两个“*“号的作用是粗体，一个“\\”的作用是斜体*","categories":[],"tags":[]},{"title":"20171110","slug":"20171110","date":"2018-03-22T08:18:03.719Z","updated":"2017-12-22T06:34:22.101Z","comments":true,"path":"2018/03/22/20171110/","link":"","permalink":"http://yoursite.com/2018/03/22/20171110/","excerpt":"","text":"MySQL索引普通索引、唯一索引（索引值唯一，unique关键字）、全文索引（fulltext关键字可以设置，只能创建在char，varchar，text类型的字段上）、单列索引、多列索引、空间索引（只有 MyISAM支持，只能建立在空间数据类型上）。 create table 表名( 属性名 数据类型[约束条件]， ………… [UNIQUE|FULLTEXT|SPATIAL] INDEX KEY [别名] (属性名[(长度)] [ASC|DESC]) ); 举个栗子 create table student（ id int not null primary key auto_increment, abd varchar(50), index hahaha(id)）; 索引名是hahaha，索引的内容是id列，哈哈哈是别名，如果不指定别名将直接使用列名作为索引名 在已有表上新建索引 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX index_name ON table_name(属性 [(length)] [ASC | DESC]); 修改表结构添加索引 alter table 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX index_name (属性 [(length)] [ASC | DESC]); 注意上面两种的区别，主要需要注意的地方是前者是表名+列名“table_name(属性 [(length)] [ASC | DESC])”，后者是索引名+列名“INDEX index_name (属性 [(length)] [ASC | DESC])”。用show create table 表名可以查看该表的定义 存储过程delimiter // create procedure 存储过程名（参数的输入输出类型 参数名 参数类型，………） begin SQL语句 end// sql语句中用“；”作为结束标志，所以在定义存储过程之前应该将语句结束标志换成其他字符，更改结束标志可以用关键字“delimiter”。 存储函数delimiter // create function 存储函数名（参数名 参数类型，………） returns 返回值类型 begin SQL语句 end// 这个地方需要注意的是返回值类型前面的是returns 局部变量声明declare 变量名 变量类型；局部变量只在某个begin······end块内有效 会话变量会话变量不必声明，可以直接使用，会话变量名以“@”为起始字符。 变量赋值 declare 变量名 变量类型 default 默认值； set 变量名=值； select 字段1名 INTO 变量名 FROM 表名 where condition 。。。。将表中满足condition的部分的字段1的内容赋值给变量。这种方式只能在begin和end之间使用。 游标有时候查询语句的结果是多条语句，使用游标必须先声明 declare 游标名 cursor for SELECT_STATEMENT 使用游标之前必须“open 游标名”，游标在顺利打开之后可以使用FETCH·····INTO语句来读取数据。 FETCH 游标名 INTO 变量名········ 变量名必须提前定义好，使用完毕之后要关闭游标 “close 游标名” 流程控制语句if语句IF condition THEN ELSE condition THEN ······ ELSE ······ ENDIF; CASE语句 case 变量名 when value THEN······ when value THEN······ else （和switch里面的default类似，默认语句） end case; while循环语句while condition do ······· end while; loop循环语句loop循环名:loop ······· 满足条件 leave loop循环名; end loop; repeat循环repeat ······ until condition end repeat 前面的三种循环中可以使用“iterate label”，和java中的continue关键字同样的作用，直接开始下一次循环 调用存储过程”call 存储过程名（存储过程的参数）;“，在命令行下，这里的参数如果是输入参数就直接输入值，如果是输出参数则使用全局变量，再通过select 输出变量值。 调用存储函数存储函数和MySQL内部函数的使用方法基本相同，“select 存储函数名（存储函数参数）;” 查看存储过程和函数show { procedure | function } status [like &apos;pattern&apos;] 和 show create{ procedure | function } 存储过程和函数的名字 第一种只能用like关键字匹配存储过程和函数名称。如果要查看详细定义，需要使用show create语句。 目前MySQL还不提供对已存在的存储过程和函数的代码进行修改，如果一定要修改只能删除后重新定义。现在只能修改对于存储过程和函数的权限和解释。 ALTER {PROCEDURE | FUNCTION} sp_name [characteristic……] 参数说明Sp_name，表示存储过程或函数的名称characteristic，表示要修改存储过程的哪个部分Characteristic的取值如下 CONTAINS SQL，表示子程序包含SQL语句，但是，不包含读或写数据的语句NO SQL，表示子程序中，不包含SQL语句READS SQL DATA，表示子程序中，包含读数据的语句MODIFIES DATA，表示子程序中，包含写数据的语句SQL SECURITY {DEFINER | INVOKER}，指明谁有权限来执行DEFINER，表示只有定义者，自己才能够执行INVOKER，表示调用者可以执行COMMENT’string’，表示注释信息 捕获存储过程中的错误预测程序在执行过程中可能出现或遇到的问题先用declare语句定义条件，语法格式如下 declare 条件名称 CONDITION FOR condition_value condition_value：SQLSTATE sqlstate_value | mysql_error_code，其实这里类似于给condition_value起了个别名,其实并不是很需要这一步。 定义处理程序 declare handler_type handler for condition_value[,...] sp_statement 其中, handler_type的取值范围：continue | exit这个语句指定每个可以处理一个或多个条件的处理程序。如果产生一个或多个条件，指定的语句被执行。 对一个continue处理程序，当前子程序的执行在执行处理程序语句之后继续。对于exit处理程序，当前begin…end复合语句的执行被终止。 condition_value的取值范围：sqlstate [value] sqlstate_value | condition_name | sqlwarning | not found | sqlexception | mysql_error_code SQLWARNING是对所有以01开头的SQLSTATE代码的速记。NOT FOUND是对所有以02开头的SQLSTATE代码的速记。SQLEXCEPTION是对所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的速记。 sp_statement 是错误处理代码","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"数据库","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"20180319","slug":"20180319 struts","date":"2018-03-19T00:37:12.000Z","updated":"2018-03-22T03:16:52.916Z","comments":true,"path":"2018/03/19/20180319 struts/","link":"","permalink":"http://yoursite.com/2018/03/19/20180319 struts/","excerpt":"","text":"一个表单里包含多个提交按钮，分别提交给不同的控制逻辑，和上周方法不同的方法是，将一个Action处理类定义成多个逻辑Action，在struts.xml中配置action的时候可以指定method属性来让action调用特定的方法处理，而不是默认使用execute方法，这些方法必须具有相似的方法签名，形参列表为空，方法返回值为String。 在struts.xml中配置action允许在指定name属性时使用模式字符串（用*代表一个或者多个任意字符），接下来就可以在class、method和result元素中使用{N}的形式代表前面第N个星号（*）所匹配的子串 &lt;action name=&quot;*Action&quot; class=&quot;cc.LoginRegistAction&quot; method=&quot;{1}&quot; 上面的这段代码其实就是根据传入的action名称选择method，也可以在类名里面使用{N}，没有为Action指定class属性，该action使用ActionSupport作为处理类，而且因为该ActionSupport类的execute方法默认返回success字符串 如果有URL为abcAction.action的请求，如果struts.xml文件中有名为abcAction的action，则一定由该action处理用户请求，如果struts.xml文件中没有名为abcAction的action，则搜寻第一个个能够匹配abcAction的Action，例如*Action和*，*Action并不会比*匹配的优先级高，先找到那个Action就由哪个Action处理请求。所以说name=“*”的Action一般配置在最后。 配置默认Action通过&lt;default-action-ref…../&gt; ，struts.xml文件中使用&lt;result…./&gt;元素配置结果，根据&lt;result…/&gt;元素所在位置的不同，struts2提供了两种结果，局部结果（result作为action的子元素）和全局结果（result作为global-results的子元素），配置result元素的时候通常要指定两个属性name和type，Struts2默认的结果类型就是dispatcher，所以在配置result的时候可以省略type元素，默认name是success，没有指定location参数，会把&lt;result….&gt;………中间的字符串当成实际视图资源。 如果result的type是plainText的话将会返回网页源代码，指定location和charSet（处理字符集）；result的结果如果是redirect；类型，将产生新的请求，所有的请求参数、请求属性、Action实例和Action中封装的属性全部丢失。使用redirect类型的结果时，不能重定向到/WEB-INF/路径下任何资源，因为web应用的/WEB-INF/路径下的所有资源是受保护对象；redirectAction结果类型和redirect都是重新生成全新的请求，配置redirectAction的时候需要指定两个参数actionName和namespace。 配置result元素的时候，不仅可以使用${0}表达式形式来指定视图资源，还可以使用${属性名}的方法指定，属性名就是对应的Action实例里的属性，OGNL表达式就是${属性名.属性名.属性名…….}，如果result放在global-results元素中配置的话，该result元素就是全局结果，对所有的Action都有效，但是局部结果会覆盖全局结果。 PreResultListener是一个监听器接口，他在Action完成控制处理之后，系统转入实际的物理视图之间被回调，可以为Action和拦截器添加这个监听器，监听器中一个方法叫做beforeResult。 struts2 异常处理在execute中处理异常的比较麻烦的，最好的处理异常的方法是通过声明式的方式管理异常处理。因为如果写在代码里异常发生变化需要重新修改代码。struts2的异常处理机制需要一个拦截器，但是默认已经开启。 异常处理实在struts.xml中配置exception-mapping元素完成的，配置该元素的时候需要制定两个属性，一个是exception，一个是result，根据exception-mapping出现的位置可以分为全局异常映射和局部异常映射，同样，局部异常映射会覆盖全局异常映射。 在struts2中可以通过如下标签输出异常信息 &lt;s:property value=&quot;exception&quot;/&gt;：输出异常对象信息 &lt;s:property value=&quot;exceptionStack&quot;/&gt;：输出异常堆栈信息 Convention插件与“约定”支持约定优于配置，只需要按照约定开发，不需要进行配置，只需要把convention的jar包导入到lib中。 Convention插件会把所有实现了com.opensymphony.xowrk2.Action的java类和所有类名以Action结尾的Java类作为Action处理。默认值只会处理action、actions、struts、struts2包下的java类，这个插件还可以设置不扫描哪些包下的java类，以及新增需要扫描的包，以及设置包搜索开始的根包。根命名空间就是上面说过的默认的扫描文件，下面的子包则被映射成对应的命名空间。 Action的name属性根据Action类的类名映射，如果该Action类名中包含Action后缀，就将Action去掉，将剩余的驼峰写法（每个单词首字母大写）转成中划线写法（所有字母小写，单词与单词之间以中划线隔开），在使用这个action的时候应该是命名空间/Action名称 按照约定映射Result，默认情况下，Convention总会到Web应用的WEB-INF/content，定位资源的约定是ActionName+resultCode+suffix（后缀），找不到对应资源的时候会使用actionname+suffix作为资源，action的url中是带着命名空间的，那么在content中也需要带上命名空间。 如果希望一个Action结束处理后进入另一个Action形成Action链，那么就不能包含第一个Action逻辑视图字符串对应的视图资源，而且第一个Action和第二个Action处于同一个包之下，第二个Action映射的URL为第一个action的名称和resultcode，例如名为FirstAction的Action返回了值为second的resultcode，那么第二个Action的类名是FirstSecondAction Convention插件支持自动重加载机制，需要设置struts.devMode为true，以及struts.convention.classes.reload为true 使用Struts2的标签库标签库的标签不依赖于任何表现层技术，struts2的标签都定义在URI为“/struts-tags”的空间下 Ajax（Asynchronous JavaScript And XML） OGNL（struts2标签库的语法）Struts2可以直接从对象中获取属性，会自动搜寻Stack Context的所有实体，从栈顶到栈底 ，知道找到与求值表达式匹配的属性，Stack Context的根对象是ValueStack，除此之外还包括了命名对象，struts2还提供了命名对象，访问这些对象需要使用#前缀来指明，parameters对象（访问http请求参数）、request对象、session对象、application对象、attr对象（该对象将依次搜索如下对象：PageContext、HttpServletRequest、HttpSession、ServletContext中的属性） 可以在任意页面增加&lt;s:debug/&gt;标签，该标签将生成一个链接，可以进行调试。 直接创建List类型集合的语法：{e1,e2,e3………}；直接生成Map类型集合的语法是#{key1:value1,key2:value2,…………}；in和not in可以用来判断某个元素是不是在指定集合中。 OGNL还允许通过某个规则取得集合的子集，？（取出所有符合选择逻辑的元素）、^（取出符合选择逻辑的第一个元素）、$(取出符合所有选择逻辑的最后一个元素)。preson.relatives.{? #this.gender==’male’}直接在集合后紧跟.{}运算符勇于取出该集合的子集，#this代表集合里的元素。 struts2提供了访问静态成员的方法，但默认是关闭的，需要设置struts.ognl.allowStaticMethodAccess设置为true。可以通过@className@staticField和@className@staitcMethod（val） OGNL支持基本的Lambda表达式语法，可以使用函数 &lt;s:iterator…./&gt;标签有三个属性：value指定被迭代的集合。id是集合里元素的id（迭代变量）","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"Struts","slug":"Struts","permalink":"http://yoursite.com/tags/Struts/"}]},{"title":"20180313","slug":"20180313 struts","date":"2018-03-13T00:55:12.000Z","updated":"2018-03-20T01:59:13.396Z","comments":true,"path":"2018/03/13/20180313 struts/","link":"","permalink":"http://yoursite.com/2018/03/13/20180313 struts/","excerpt":"","text":"eclipse生成部署Web项目的时候，会自动将src路径下除了*.java外的所有文件都复制到web应用的WEB-INF\\classes路径下。 在WebContent下面的文件在配置中就是从根目录开始的，如果是WebContent下面的子文件夹，比如是WEB-INF中的content文件下的mo.jsp文件需要设置为/WEB-INF/content/mo.jsp Struts2推荐把所有视图页面存放在WEB-INF目录下，避免直接向视图界面发送请求，struts.xml中配置了一个name=“*”的&lt;action……/&gt;，这个元素可以处理所有的请求，直接呈现WEB-INF/content目录下同名的jsp页面。 Struts2应用的开发步骤 在web.xml中定义filter拦截用户请求 如果以post方式提交请求，则需要定义包含表单数据的jsp页面，如果仅仅是get方式，则无需经过这一步。 定义处理用户请求的Action类（Actionsupport）。Action是MVC里的C 配置Action。指定哪个请求对应于哪个Action进行处理。Convention插件支持“约定优于配置”的思想，采用约定的方式来规定请求和action之间的对应关系。 通常action处理用户请求之后会返回一个字符串，在struts.xml中可以配置这个字符串和物理视图（要返回给用户的界面）之间的对应关系 如果action需要发送数据给试图自愿，可以借助DGNL表达式。 Struts.xml通常放在web应用的类加载路径下，通常是放在WEB-INF/classes路径下，主要作用就是配置action和请求之间的对应关系，还可以使用struts.properties文件来管理常量，标准properties文件，key-value对。这些常量会对整个struts2应用起作用，同样放在WEB-INF/classes下。 struts2会自动加载struts.xml（开发者自定义配置文件）、struts-default.xml（struts2自带配置文件）、struts-plugin.xml（struts2插件的配置文件） Struts2配置常量有三种方式：struts.properties\\struts.xml\\web.xml，在struts.xml中可以通过constant元素配置，在web.xml中配置StrutsPrepareAndExecute时也可以配置struts2常量，通过为filter配置初始参数的方法配置struts2常量 struts2框架加载常量的顺序是struts-default.xml、struts-plugin.xml、struts.xml、struts.properties、web.xml，后面的重名常量会覆盖之前的常量。 为了避免struts.xml文件过于庞大，所以可以通过include元素手动导入配置文件 &lt;s:textfield name=&quot;Xxx&quot; key=&quot;&quot;&gt; name是action定义类中的常量名称，key是显示在页面上的文字 Action中的实例变量不仅可以封装请求参数，也可以用来封装处理结果 Action接口规范中统一定义了5个字符串常量：ERROR、NONE、INPUT、LOGIN、SUCCESS，实现类ActionSupport Web应用中经常要用到HttpServletRequest、HttpSession、ServletContext，这三个分别是jsp内置对象中的request、session和application，Struts2提供了ActionContext Action直接访问Servlet API，实现三个接口就可以实现，ServletContextAware、ServletRequestAware、ServletResponseAware ServletContext是在服务器上共享的一片区域，而session则是每一个用户自有的一块区域。 Struts2中的Action在一个包中，包用package配置，每个包里面有很多个Action和拦截器，package的name属性是引用该包的唯一标识。extend属性可以用来继承另一个包，还有抽象包的概念，抽象包不能有Action的定义。 interceptors是拦截器，下面的这段代码的action的name是*，代表请求的网页是和action同名的jsp &lt;action name=&quot;*&quot;&gt; &lt;result&gt;/WEB-INF/content/{1}.jsp&lt;/result&gt; 每次定义一个package元素的时候，都可以指定一个namespace属性，因为同一个web应用可能会包含同名Action，如果配置package的时候没有指定namespace，当某个包指定了命名空间，该包下所有的action处理的URL应该是命名空间+Action名，当系统收到请求时，会现在命名空间里查找，如果没有的话会去默认空间查找。 同一个页面里的不同按钮想要交给不同的控制逻辑，也就是说一个jsp页面中的提交想要分别提交给action的不同方法处理，action=“actionName！MethodName”，通过一个jsp的函数在点击按钮之后利用onclick动态的改变了表单的action，这种方法就是动态调用，动态调用的方法除了函数名和execute方法不同之外，其他的都必须一样。使用动态调用必须要设置struts2允许动态调用，设置struts.enable.DynamicMethodInvocation常量为true。","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"Struts","slug":"Struts","permalink":"http://yoursite.com/tags/Struts/"}]},{"title":"JavaEE","slug":"JavaEE","date":"2018-01-18T08:10:39.000Z","updated":"2018-03-13T02:49:31.290Z","comments":true,"path":"2018/01/18/JavaEE/","link":"","permalink":"http://yoursite.com/2018/01/18/JavaEE/","excerpt":"","text":"Java EE应用的分层模型大致有如下几层： Domain Object(领域对象层)：一些简单的java类，类内部包含了业务的实现逻辑。 DAO（Data Access Object）：对数据库的操作。 业务逻辑层：这些业务逻辑方法可能仅仅用于暴露Domain Object对象所实现的业务逻辑方法或者DAO组件的业务逻辑方法。 控制器层：拦截用户请求，调用业务逻辑组件的方法。 表现层：一系列页面组成，负责收集请求，并显示处理结果。最常见的技术是JSP（Velocity、FreeMarker和Tapestry） 保证业务逻辑方法的实现，与具体的持久层访问技术分离，持久层我的理解就是数据和物理设备之间的操作。 JSP不能直接访问应用的底层状态，Java EE会使用选择JavaBean来传输数据， Struts是MVC框架，同时替代技术有Spring MVC和JSF JavaEE应用需要一种能够让Java以面对对象的方式操作关系数据库的技术，ORM（Object Relation Mapping），Hibernate框架是一种开源的、轻量级的ORM框架，他允许将普通的、传统的Java对象（POJO）映射成持久化类，允许应用程序以面向对象的方式才操作POJO，而Hibernate框架负责将这种操作转换成底层的SQL操作。Mybatis允许将SQL语句查询结果映射成对象，是Hibernate的替代技术。 Spring框架里包含各种设计模式的应用，中间层容器，向上与MVC框架无缝融合，向下可以与各种持久层框架无缝整合。没有替代技术。 在Tomcat中部署Web应用的方式有四种： 利用Tomcat的自动部署。 利用控制台 增加自定义的web部署文件 修改server.xml文件部署web应用 Ant是java世界的Make，利用build.xml完成整个项目的编译，Ant工具会根据build文件中的配置进行整个项目的编译，project文件夹下包含了src（源文件、各种配置文件）、classes（编译后的class文件）、lib（第三方jar）、dist（项目打包和项目发布文件的文件夹）、build.xml（Ant生成文件） build文件中的根元素是project，每个项目下可以定义多个生成目标，每个生成目标用target标签来定义，target的属性有name（运行target的时候就是根据name属性确定目标）、depends（运行该target之前必须运行depends指定的target）、if（if属性指定一个属性，只有这个属性被设置了才会执行target）、unless（这个属性没被设置才会执行这个target）、description build文件中的property元素用来定义一个或者多个元素，该元素有name和value属性，而且该属性值不可改变，需要获取属性值，${property的name属性}，属性值的来源可以是属性文件的文件名、属性文件的资源名称、属性文件的url地址、系统环境变量、或者是属性文件的classpath。 Mavenmaven常用的命令就是mvn。mvn的主要格式是mvn : -D &lt;属性名&gt;=&lt;属性值&gt; ········plugin-prefix是插件前缀，goal就是指定目标，-D就是用来指定属性名和属性值 使用http://maven.apache.org/plugins/index.html可以查看Maven插件的功能和用法，创建项目使用Maven的archetype插件 用maven生成的项目中包含一个pom（project object model ）文件。该文件仅仅包含了一些项目的版本、groupID、artifactid等坐标信息 mvn archetype:generate -DinteractiveMode=false -DgroupId=org.fkjava -DartifactId=mavenQs -Dpackage=org.fkjava.mavenqs mvn compile mvn exec:java -Dexec.mainClass=&quot;org.fkjava.mavenqs.App&quot; 即便该项目的POM文件中没有说明maven编译项目的具体过程，是因为当前项目的pom文件会被合并到上级pom文件中，上级的pom文件中定义了项目的大量默认设置。 Maven的插件可以指定多个可执行的目标，对于软件构建过程，默认的生命周期是compile、test、package、install、deploy。POM为项目提供一个唯一标识符，这个就是Maven坐标，由groupID（该项目开发者的域名）、artifactid（项目名）、packaging（打包类型）、version（项目版本），Maven坐标可以精确定位一个项目。 Servlet/jsp回顾web目录中的classes和lib文件夹都是用来保存web应用所需要的Java类文件，classes保存单个的class文件，而lib保存打包以后的jar文件 java脚本 &lt;% %&gt; jsp注释 &lt;%– –%&gt; jsp声明 &lt;%! %&gt; 输出jsp表达式 &lt;%=表达式 %&gt;输出表达式语法后不能有分号 JSP的3个编译指令&lt;% 编译指令名 属性名=“属性值” %&gt; page\\include\\taglib jsp动作指令主要有如下7个： jsp:forward:页面转向 jsp:param：传递参数（forward和include需要使用该指令） jsp:plugin：下载JavaBean或者applet到客户端执行 jsp:useBean：创建javaBean jsp:setProperty：设置JavaBean的属性值 jsp:getProperty：输出JavaBean的属性值 jsp:include: 动态引入jsp页面（被导入页面的body内容插入本页面） 通常不使用response直接响应，都是使用out对象，response常用于重定向，以及输出非字符对象。 jsp和servlet之间的数据交换是通过四个map结构，application、session（会话）、request（请求）、page。请求就是一次点击，会话就是浏览器的一个标签页，application就是整个服务器上所有的jsp和servlet都可以交换信息。 如果希望jsp页面可以获取web.xml配置文件中的配置信息，则必须通过为该jsp配置的路径访问该页面 jsp中的9个内置对象： application config exception：只有在errorpage中才可以用 out pageContext：可以访问page、request、session、application范围的变量，pageContext还可以用来获取其他内置对象。 request response session GET方式发送的请求参数被附加到地址栏的URL之后，url?param1=value1&amp;param2=value2&amp;········paramN=valueN post请求中的非西欧字符可以通过设置request的编码字符集，但是get请求中的非西欧字符（包括中文字符）只能通过java.net.URLDecoder类 使用request的getRequestDispatcher（String path）方法的时候，该path字符串必须以斜线开头。 response的重定向会丢失所有的请求参数和request范围的属性，二forward将会保留所有的请求参数。 一次用户会话的含义是：客户端浏览器链接服务器开始，到客户端浏览器与服务器断开为止，这个过程就是一次会话 HttpServlet包含init方法和destroy方法，这两个方法无须重写，除非在初始化servlet时，完成某些资源初始化的方法，才考虑重写init方法，销毁servlet之前先完成对于某些资源的回收才需要重写destroy。 为了让servlet响应用户请求，必须将servlet配置在web应用中，配置servlet有两种方式：1. 在servlet类中使用@WebServlet注解进行配置2.通过在web.xml文件中配置。 metadata-complete=”true”，会在启动时不扫描注解（annotation）。如果不扫描注解的话，用注解进行的配置就无法生效 有一种servlet在应用启动的时候就创建，用于某些后台服务的servlet或者是拦截请求的servlet。load-on-startup Servlet，配置的方式有两种：@WebServlet注解的loadOnStartup属性指定。或者是在web.xml中利用load-on-startup子元素进行配置，有一个整数值表示优先级，越小就越先实例化。 在web.xml中写明的Servlet参数可以通过ServletConfig对象完成。ServletContext获得的是整个Web应用的配置参数。 tld文件应该在WEB-INF的任意子路径下（tld文件是对自定义标签库的定义文件），tld文件中的uri是非常关键的，在使用自定义标签的时候需要明确uri才能找到指定的标签库 getJspBody()可以获得自定义jsp标签里的标签体 以“页面片段”为属性的标签需要在标签处理类中定义类型为JSPFragment的属性，这个属性代表“页面片段”，使用标签库的时候，通过jsp:attribute.../动作指令为标签的属性指定值。 需要传入自定义标签的属性个数是不确定的，需要动态属性的标签，标签处理类需要实现DynamicAttributes接口，配置标签时通过子元素指定该标签支持动态属性。 Filter的种类：（filter的用法） 用户授权的filter：检查用户请求 日志filter：详细记录某些特殊的用户请求 负责解码的filter：对非标准编码的请求编码 能改变xml内容的XSLT Filter ServletContextListener、ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、HttpSessionListener、HttpSessionAttributeListener Servlet底层的IO是通过ServletInputStream和ServletOutputStream支持的，ServletInputStream新增了setReadListener方法，允许非阻塞IO读取数据，输出流也有同样的方法。使用的方法是： 调用ServletRequest的startAsync（）方法开启异步模式 通过ServletRequest获取ServletInputStream，并为ServletInputStream设置监听器，实现ReadListener接口来实现监听器。 Tomcat 8 的WebSocket支持使用注解方式开发，被@ServerEndpoint修饰的java类饥渴作为WebSocket服务器，这个类中有四个需要定义的方法 Tag File支持：通过建立Tag文件，利用Tag File代替了标签处理类，Tagfile有5个编译指令，分别是taglib、include、tag、attribute（类似于自定义标签处理类的属性）、variable，在使用自定义标签的时候需要先导入标签库，再使用标签，和tld文件的不同在于这里是prefix和tagdir，tagdir标签库路径下存放着很多Tag File。每个Tag File对应着一个标签。 Servlet3.0 异步处理是通过AsyncContext类来处理的，AsyncContext类的dispatch方法把请求dispatch到指定JSP页面，被异步请求dispatch的目标界面需要在指定session=false，这样新的页面才不会重新创建session，异步调用需要配置，异步调用有自己的监听器，监听器需要实现AsyncListener接口 ，这里的监听器不像是servlet那种只要配置了就会自动运行的监听器，这个异步监听器必须注册在某个异步调用上。 HttpServletRequest增加了对文件上传的支持 ServletContext可以通过编程的方式动态注册servlet和filter HttpServletRequest提供了获得part的方法，每个part对应一个文件，part也有write的方法可以将上传文件写入到服务器的磁盘里。在页面中就需要设置input type=file，并且需要将表单域的enctype属性设置为multipart/form-data。","categories":[],"tags":[]},{"title":"20180116","slug":"20180116","date":"2018-01-11T08:40:38.000Z","updated":"2018-01-18T08:46:42.404Z","comments":true,"path":"2018/01/11/20180116/","link":"","permalink":"http://yoursite.com/2018/01/11/20180116/","excerpt":"","text":"Web容器安全管理&lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;/auth-method&gt;&lt;!--定义验证方式,basic是基本验证方式--&gt; &lt;/login-config&gt; &lt;security-role&gt; &lt;role-name&gt;admin&lt;/role-name&gt; &lt;/security-role&gt; &lt;security-role&gt; &lt;role-name&gt;manager&lt;/role-name&gt; &lt;/security-role&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Admin&lt;/web-resource-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;http-method&gt;GET&lt;/http-method&gt;&lt;!--可以添加多个，只能分开写,默认设置代表所有的http方法都会受到限制--&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; BASIC的验证方式只能通过对话框输入名称和密码，使用基本验证时无法自定义登录页面，如果需要自定义登录界面和登陆错误的页面，则可以改用容器所提供窗体验证。 &lt;login-config&gt; &lt;auth-method&gt;FORM&lt;/auth-method&gt; &lt;form-login-config&gt; &lt;form-error-page&gt;登录错误页面&lt;/form-error-page&gt; &lt;form-login-page&gt;登录页面（路径必须从应用程序的根目录开始）&lt;/form-login-page&gt; &lt;/form-login-config&gt; &lt;/login-config&gt; 这种FORM的方式在容器验证成功之后会在HttpSession中设置登录字符，所以可以通过检查字段的方式确实是否登录以及完成注销机制的设计。发送的URL、发送名称的请求参数和发送密码的请求参数都是固定不变的。 除了BASIC和FORM之外，还可以设置DIGEST（摘要验证，在网络上传输的是密码的MD5值）和CLIENT-CERT（采用证书的安全机制） web应用程序采用HTTP over SSL是比较安全的方式，也就是HTTPS，在web.xml中的设置 &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt; 的默认值是NONE，还可以设置为CONFIDENTIAL（机密性），INTEGRAL（完整性），两个效果都是一样的 request.isUserInRole方法可以判断登录用户的角色。 整合数据库 加载JDBC驱动程序：通过java.lang.Class类的forName，动态加载驱动程序类，Class.forName(“com.mysql.jdbc.Driver”)，不同的数据加载不同的类。 提供JDBC URL，JDBC URL定义了连接数据库时的协议等标识。。jdbc：mysql:://主机名称：连接端口/数据库名称？参数=值&amp;参数=值，参数包括用户名、密码、useUnicode（是否使用unicode）、character-Encoding（字符编码方式），xml文件中不能出现“&amp;”，所以用“&amp;amp；”代替。 取得Connection实例：coon=DriverManager.getConnection（url），url是第二部里面的URL；当数据库管理人员不想告诉开发人员数据库的密码和用户名时，开发者可以通过JNDI的方式获得Connection 设计模式 Template Method模式（Gof设计模式）：父类会定义服务流程的方法，子类继承或者覆写实现具体的流程。 Intercepting Filter模式（Java EE设计模式）：过滤器 Model-View-Controller模式（架构模式）：MVC以及Model 2 模式 Business Delegate模式： Business Delegate是中间件，它接收到请求之后交给其他部分处理并由其他部分返回结果，降低耦合度。 Service Locator模式：类似于前一个，隐藏复杂的操作。 Transfer Object模式：可以把一些信息封装在某个类中，传输类，比如说图书管理系统里的图书类或者用户类。 Front Controller模式：FrontController负责了集中管理所有与请求相关的动作，处理完毕之后委托给其他对象（不建议） 结语看到今天，这本Servlet与Jsp终于看完了，java web的路线还有spring、struts和MyBatis，Hibernate，这几个准备在暑假看看有没有实战的项目，设计模式现在不准备深入研究，只是先通过项目学习一下。以后也不一定就一定搞这个，但是干一行精一行还是很有必要地~~~~下次准备把一本书的内容都写在一起，每周分开就好了，之前这本书看的太乱，大概写了十几个md文件。 python 从raw_input()读取的内容永远以字符串的形式返回。 list是可变列表，tuple是不变元组，变不变指的是内存指向。 dict相当于其他语言里的map，python里面在交互式命令行模式下当返回None的时候不显示结果。dict里的key是不可变对象。 set是集合，没有重复元素。可以重复添加，但没有效果。两个集合可以利用“&amp;“和”|“做数学意义上的交集和并集。 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 python里面函数不需要写明返回值的类型，可以返回多个值，但实际上仍然是一个tuple。函数的默认参数写在定义函数的地方。 def enroll(name, gender, age=6, city=’Beijing’): enroll(&apos;Sarah&apos;, &apos;F&apos;) enroll(&apos;Bob&apos;, &apos;M&apos;, 7) enroll(&apos;Adam&apos;, &apos;M&apos;, city=&apos;Tianjin&apos;)` 默认参数必须指向不变对象。 可变参数传入函数的时候会自动组装成一个tuple. def calc(*numbers): sum=0 for n in numbers sum=sum+n*n return sum 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。 关键字参数有什么用？它可以扩展函数的功能。 def person(name,age,**kw): #kw是关键字参数 参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。 尾递归是指在函数返回的时候，调用自身本身，并且，return语句不能包含表达式，理论上可以防止栈溢出，但是Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。 字符串、元组、列表切片[起始元素:终止元素:步长]，步长省略时为1，起始元素从0开始，不包括终止元素。 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems() 如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断，isinstance(‘abc’, Iterable) # str是否可迭代 列表生成式 [要生成的元素 for 迭代元素 in 迭代的集合或者列表等等一切可以迭代的东西)] >&gt;&gt;L=[x*x for x in range(10)]>&gt;&gt;L[0,1,4,9,16,25,36,49,64,81] 创建一个generator，只要把一个列表生成式的[]改成()，就创建了一个generator，通过for循环迭代所有的内容。 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。 函数名也是变量，函数名也可以赋值给其他变量，一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。 reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算 字典的定义是用大花括号{}，集合set的输出结果中[]并不代表是列表。 Python内建的filter()函数用于过滤序列。filter()接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1。 sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。 关键字lambda表示匿名函数，冒号前面的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。匿名函数也是函数。 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） 把@log放到now()函数的定义处，相当于执行了语句：now = log(now) functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单. 每一个包目录下面都会有一个init.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。init.py可以是空文件，也可以有Python代码，因为init.py本身就是一个模块。 今天决定python只学习自己需要的部分，所以不准备所有都看了，之前看的一些高级特性都没搞明白。 当我们在命令行运行模块文件时，Python解释器把一个特殊变量name置为main，而如果在其他地方导入该模块时，if判断将失败。 if name=’main‘: test() 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public，类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。 安装第三方库的时候使用“pip install 模块名” 。 定义类，init方法的第一个参数永远是self，表示创建的实例本身，因此，在init方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身 class Student(object): def init(self,name,score): self.name=name self.score=score 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。 当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。 如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。 如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。Python内置的logging模块可以非常容易地记录错误信息。 可以捕获错误之后打印错误又把错误抛出，因为当前函数可能不能处理，raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型。 调试的方法有以下几种：用print发现错误的地方、用assert发现错误的地方、用logging记录错误的地方、启动Python的调试器pdb。 pdb.set_trace()是用来调试比较简单的部分，只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行。 要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符。文件对象必须close，但是“with open(‘/path/to/file’, ‘r’) as f： ”，使用前面这种方式打开就不必调用f.close()方法，调用read()会一次性读取文件的全部内容，可以反复调用read(size)方法，每次最多读取size个字节的内容。调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。 要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可。 multiprocessing模块提供了一个Process类来代表一个进程对象，创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动。 如果要启动大量的子进程，可以用进程池的方式批量创建子进程。 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行。 多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，多线程需要考虑同步的问题。 线程同步的时候需要用到lock， lock.acquire()， lock.release()，当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。用try…finally来确保锁一定会被释放。","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"数据库","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"jsp","slug":"Jsp","permalink":"http://yoursite.com/tags/Jsp/"},{"name":"servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"20180108","slug":"20180108","date":"2018-01-08T00:55:12.000Z","updated":"2018-01-16T01:23:13.824Z","comments":true,"path":"2018/01/08/20180108/","link":"","permalink":"http://yoursite.com/2018/01/08/20180108/","excerpt":"","text":"写在前面周六晚上熬夜到四点，导致周日没睡好，周日晚上也没睡好，因为周一要去实验室，上一周忙着考试，所以没学什么知识，这周虽然有个很扯的活要干，但是好歹有自己的时间，虽然现在还是很困。 现在在学的部分是jsp中的JSTL，主要作用是来替换JSP页面中的scriptlet。 正文 之前所有的异常都是设置专用的错误网页，将出现的错误转发到其他页面进行处理展示，如果要在发生异常的网页捕捉异常，JSTL的标签&lt;c:catch&gt;标签捕捉本网页的异常对象，使用&lt;c:catch&gt;将可能产生异常的网页段落包起来，如果真的发生了异常，会把异常对象设置给&lt;c:catch&gt;里面的var属性所指定的名称，异常都是Throwable的子类，都拥有getMessage（）的方法。 导入JSP网页到目前网页的方式：1. 通过include指示元素可以直接将两个JSP网页直接拼接在一起，2. jsp:include标签可在运行时期依条件动态决定是否包括另一个网页。 &lt;isp:include page=&quot;Xxx.jsp&quot;&gt; &lt;jsp:param name=&quot;a &quot; value=&quot;c &quot;&gt; &lt;jsp:param name=&quot;b&quot; value=&quot;d&quot;&gt; &lt;/jsp:include&gt; 在JSTL中有&lt;c:import&gt;标签，搭配&lt;c:param&gt;在导入另一网页时带有参数 &lt;c:import url=&quot;Xxx.jsp&quot;&gt; &lt;c:param name=&quot;a&quot; value=&quot;c&quot;&gt; &lt;c:param name=&quot;a&quot; value=&quot;c&quot;&gt; &lt;/c:import&gt; 这个标签也可以导入非目前web程序中的网页 \\jsp:setProperty\\ 只能用来设置JavaBean的属性，设置其他的值需要使用&lt;c:set&gt;，set中的scope属性用来设置范围，var属性是变量名，value是值 &lt;c:set var=&quot;login&quot; value=&quot;${user.name}&quot; scope=&quot;session&quot;/&gt; &lt;c:set var=&quot;details&quot; scope=&quot;session&quot;&gt; caterpillar,openhone &lt;/c:set&gt; &lt;c:set&gt; 里面没有指定属性的时候，会从page、request、session、application的范围寻找属性名称，找到就在该范围内设置，都没找到就在page范围内设置，移除属性可以使用&lt;c:remove&gt;,&lt;c:set&gt;还可以用来设置JavaBean的属性或者是Map对象的键值，必须使用target属性进行设置。 &lt;c:out&gt;可以输出指定的文字，value属性需要设置成想要输出的文字。&lt;c:out&gt;会自动替代里面出现的可能在HTML中的字符，EL运算结果为null时，不会显示任何值，但如果想要显示默认值，不需要检查是否为空，可以直接 &lt; c : out value=”${param.a}” default=”0”/&gt; response的encodeURL用作URL重写，以在用户关闭Cookie功能时，仍然可以继续利用URL重写来维持使用session进行会话管理，如果不想使用scriptlet编写response的encodeURL，则可以使用JSTL的&lt;c:url&gt;，它会在用户关闭Cookie功能的时候，自动用SessionID作URL重写，标签里可以加上&lt;c:param&gt; Tag File自定义标签（tag文件）如果有现成且通用的自定义标签库，不需要重复造轮子。 使用自定义的tag标签，需要新建扩展名为tag的文件，并放在WEB-INF/tags下面，把tag的定义写在扩展名为tag的文件中，开始的时候需要用tag指示元素说明信息，在需要使用这个tag的JSP页面中，可以使用taglib指示元素的prefix定义前置名称，以及使用tagdir属性定义tag file的位置（tagdir只能指定/WEB-INF/tags的子文件夹），然后就可以在想要使用的地方写上prefix+tag文件名。这里存在的一个问题就是tag的定义文件里如果使用了一些与应用程序相关的过程，就很难移植。 几个网页只有细微差别，可以写成一个Tag File，通过attribute设置不同的部分，在使用的地方的标签里通过为attribute赋值更改。Tag File也可以有主体内容，在和之间使用jsp:doBody/，这个标签可以取得使用Tag File标签时的主体内容，这个主体内容指的就是在使用标签的时候自定义的标签头和标签尾之间的内容。 Tag File 的标签在使用时有主体，默认是不允许有Scriplet，因为定义Tag File的时候tag指示元素的body-content属性默认就是scriptless，body-content属性的值还可以是empty和tagdependent，empty表示一定没有主体内容，tagdependent表示将主体中的内容当做纯文本输出。 要将tag File文件压缩成jar文件必须把tag文件封装在jar文件的META-INF/tags下，META-INF/TLDS下定义tld文件，生成的jar包放在WEB-INF/lib文件夹中就可以使用了。 尽量不要在Tag File中编写Scriptlet来操作Java对象 Simple Tag自定义标签（java自定义类）如果自定义标签时需要操作Java对象，可以考虑实现Simple Tag来自定义标签，将Java程序代码写在其中。 编写标签处理器，继承SimpleTagSupport来实现标签处理器，并重写doTag()方法进行标签处理，getJspBody()方法会返回一个JSPFragment对象，代表两个标签之间的主体内容，调用JSPFragment的invoke方法并传入一个null，表示运行标签之间的主体内容(null表示将使用PageContext取得默认的JSPWriter对象作为输出响应，也就是默认会输出到浏览器，可以把最后的结果传入其他的Writer，最后要输出的时候可以通过PageContext的getOut取得JspWriter对象。而后调用print（）方法输出结果)。在标签处理器定义的过程中需要把属性定义成类变量，在tld文件中声明之后就可以直接在使用的时候赋值。 为了让web容器了解标签和标签处理期之间的关系，需要写一个tld文件。一个tls文件中可以声明很多个tag &lt;taglib&gt; &lt;tlib-version&gt;库的版本号&lt;/tlib-version&gt; &lt;short-name&gt;自定义标签的前缀&lt;/short-name&gt; &lt;uri&gt;http://openhome.cc/jstl/fake（自定义标签的链接）&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;自定义标签名称&lt;/name&gt; &lt;tag-class&gt;实现标签的处理的类的绝对路径（包名.类名）&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;标签上属性的名称&lt;/name&gt; &lt;required&gt;是否一定要设置这个属性（true/false）&lt;/required&gt; &lt;rtexprvalue&gt;属性是否接受运行时期运算的结果&lt;/rtexprvalue&gt; &lt;type&gt;属性的类型（Boolean之类的）&lt;/type&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 使用的时候利用指示元素taglib指明prefix为前缀，URI为tld文件里的URI。 每一次请求都会创建新的标签处理器实例，执行完doTag（）之后就销毁实例，在dotag过程中需要中断输出或者处理的话可以抛出SkipPageException 与父标签的沟通标签之间的嵌套只能使用与父标签的沟通机制。书中的例子是自定义类似于&lt; c: choose &gt;和&lt; c : when &gt;、&lt; c : otherwise &gt;这种父标签和子标签的关系，&lt; c: choose &gt;作为最外层的标签，定义中有一个Boolean类型的matched变量，在when标签的定义过程中，需要设置当when标签的父标签不是choose标签的时候发生错误，其次如果父标签的metched变量为true，说明之前有when标签通过测试，matched变量就是为了表示内部的标签是否存在匹配成功的现象。when标签的定义过程中对test变量，也就是when标签中的test属性验证成功，就需要将when的父标签的matched变量设置成true，otherwise标签和when标签很类似，只不过otherwise标签没有test属性，直接执行jsp就可以了，tld文件的主要作用就是告诉web容器标签名称和我们自定义标签类的对应关系，如果某一个标签外层有很多标签，要获得指定类型的外层标签，可以通过SimpleTagSupport的findAncestorWithClass（）静态方法，会在外层标签中寻找，直到找到指定类型的外层标签对象后返回。 Tag自定义标签（java自定义类）大多数情况下simple Tag能满足自定义标签的需求，然而Simple Tag是从jsp2.0之后才出现的，了解一下Jsp2.0之前的自定义标签 和之前的差别在于继承的类不一样，继承的父类是TagSupport，调用的函数是doStartTag（）方法，该方法的返回值决定是否执行主体内容，Tag实例是可以重复使用的。所以要注意对象状态是否会保留下来，doStartTag（）方法可以进行状态重置的动作，release方法不能用来状态重置，因为release（）方法只会在标签实例真正被销毁回收， doStartTag()可以返回EVAL_BODY_INCLUDE（执行主体内容）或者SKIP_BODY（执行doEndTag方法），然后调用doAfterBody方法，返回值是EVAL_BODY_AGAIN（再次执行主体内容，然后调用doAfterBody方法，）或者SKIP_BODY（doEndTag方法），doEndTag方法的返回值是EVAL_PAGE（执行后续页面）或者SKIP_PAGE（直接结束）。上面的三个方法都有默认返回值。","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"jsp","slug":"Jsp","permalink":"http://yoursite.com/tags/Jsp/"}]},{"title":"2017122702","slug":"2017122702","date":"2017-12-27T01:54:40.000Z","updated":"2018-03-04T03:45:00.719Z","comments":true,"path":"2017/12/27/2017122702/","link":"","permalink":"http://yoursite.com/2017/12/27/2017122702/","excerpt":"","text":"JSTLJSTL（JavaServer Pages Standard Tag Library）来替换JSP页面中用来实现页面逻辑的scriptlet。 提供的标签库可以分为五类，核心标签库、格式标签库、SQL标签库、XML标签库、函数标签库。 要使用JSTL标签库，必须在网页上使用taglib指示元素定义前置名称与uri引用，JSTL的jar包需要手动添加到项目的WEB-INF/lib文件夹中，惯例上使用JSTL核心标签库的时候，会使用c作为前置名称，URI引用则告知容器如何引用JSTL标签库实现。 &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;c:if&gt;就相当于java中一个单一的if语句 &lt;c:choose&gt;、&lt;c:otherwise&gt;、&lt;c:when&gt;搭配使用就相当于java中ifelse语句以及该语句的嵌套 &lt;c:foreach&gt;就是轮询某个集合或者数组，里面的var属性就是轮询变量，items就是数组或者Collection变量 &lt;c:fortoken&gt;的主要作用就是为了将字符串按照指定的分隔符分为多个字符串，var属性表示轮询变量，delims表示分隔符，items仍然表示字符串。 错误处理标签","categories":[],"tags":[]},{"title":"20171227","slug":"20171227","date":"2017-12-27T01:06:34.000Z","updated":"2018-01-16T01:23:53.502Z","comments":true,"path":"2017/12/27/20171227/","link":"","permalink":"http://yoursite.com/2017/12/27/20171227/","excerpt":"","text":"表达式语言（EL）替换掉scriptlet编写的属性、请求参数、标头与cookie等信息的获取，或者是一些简单的运算和判断 EL是使用${与}来包括所要进行处理的表达式，EL会自行进行类型转换 可以在page指示元素的isELIgnored属性（默认为true），来设置jsp网页是否使用EL，原因是因为网页中已经使用了EL类似的语法功能，也可以在web.xml中设置标签为true，不使用EL。两种方式以前者为主 EL的应用实例 &lt;h1&gt;${user.name}&lt;/h1&gt;&lt;%--按照page、request、session、application 的顺序来寻找EL中指定的属性&gt;--% &lt;h1&gt;${user[&quot;name&quot;]}&lt;/h1&gt;&lt;%--和上面的效果相同--%&gt; 如果数组元素被设置的索引为array，setAttribute（索引，内容），List也可以使用下面的方法访问。 ${array[0]}&lt;%--第一个元素--%&gt; ${array[1]}&lt;%--第二个元素--%&gt; ${array[2]}&lt;%--第三个元素--%&gt; 点运算符左边可以是JavaBean或者Map对象 如果使用[]运算符，则左边可以是JavaBean、Map、数组或者List对象 当左边是map对象的时候，推荐使用[]运算符，因为map对象的key有可能是空白或者带有点运算符的，取值的时候两个点运算符在一起会引起错误。[]运算符内部可以进行嵌套 ${login[&quot;user name&quot;]} ${login[&quot;pass.word&quot;]} EL隐含对象11个隐含对象，pageContext对应PageContext，其他的隐含对象都对应Map类型。 pageContext：PageContext本身就是JavaBean 与属性相关的隐含对象 与请求参数相关的隐含对象： param与paranValues，param可以取得某个参数的值，paramValues可以取得所有请求参数，返回值是数组 与标头（header）相关的隐含对象：header或者headerValues cookie隐含对象：取得用户设置的cookie值 初始参数隐含对象：initParam可以用来取得web.xml中设置的ServletContext初始参数。 EL运算符%和mod都是求余运算符，关系运算符都有相应的符号和英文简称，比如&lt;以及lt（less than）、&gt;与gt（greater than）、!=与ne（not equal） 自定义EL函数第一步：编写类，这个类必须是公开类，想调用的方法必须是公开的且为静态方法。第二步：web容器必须知道如何将这个类中的方法当作EL函数使用，必须编写一个标签链接库描述文件（TLD）文件，tld文件中需要指明自定义的函数名称，对应到的类和对应到的那个类的具体方法，以及特定的URI，使用的jsp中&lt;%@taglib uri=”” prefix=””%&gt;uri是为了能够快速找到tld文件，prefix的作用是为了避免当jsp中有多个来自不同设计者的EL自定义函数会出现名称冲突。","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"jsp","slug":"Jsp","permalink":"http://yoursite.com/tags/Jsp/"}]},{"title":"20171226","slug":"20171226","date":"2017-12-26T01:54:40.000Z","updated":"2018-01-16T01:23:41.509Z","comments":true,"path":"2017/12/26/20171226/","link":"","permalink":"http://yoursite.com/2017/12/26/20171226/","excerpt":"","text":"JSPJSP和Servlet是一体两面，jsp最后还是会被容器转译为Servlet，自动编译成.class文件，载入.class文件然后生成Servlet对象。JSP出错的时候可以查看Servlet代码发现错误 不同的web容器对于JSP的转译方式是不同的，jsp转变成Servlet之后会调用_jspInit()，_jspdestroy()。一般情况下不会重写这些函数，如果想要在jsp初始化的时候做一些事情，可以选择重写JSPInit（）和jspDestroy（）。 指示元素&lt;%@ 指示类型 [属性=“值”] %&gt;（[属性=“值”] 是正则表达式） 常用的指示类型：page（告知容器如何转译目前的jsp网页）、include（将其他的jsp页面包括进来进行转译）、taglib（告知容器如何转译这个页面中的标签库） include将其他页面包含的时候是一种静态的包含方式，就是把包含的文件直接拼接在一起。 声明在&lt;%!与%&gt;之间声明的程序代码，都将转译为Servlet中的类成员或者方法。也就是说把所有的成员变量声明和方法声明的java代码都写在这个&lt;%!与%&gt;之间，容器会使用同一个Servlet来服务不同用户的请求，每个请求就是一个线程，声明 变量的时候必须小心数据共享与线程安全的问题，使用该方法声明的变量是类成员变量，JSPInit（）和JSPDestroy（）就需要使用这种方式重写。 Scriptlet元素&lt;% java语句 %&gt;所有的内容将被转译到Servlet源代码中的_JSPService（），可以利用java语句的注释方式进行注释（//或者/········/) 表达式元素&lt;%= java 表达式&gt;表达式元素不用加分号，表达式元素中的表达式会直接转译成out对象输出时的指定内容。 因此在jsp中输出&lt;%或者%&gt;符号，要将角括号置换为替代字符，&lt;%可以换成&lt;% ，%&gt; 可以换成%&gt;或者%>。 注释JSP有自己专用的注释，即&lt;%–与–%&gt;，容器在转译JSP到Servlet的时候，会忽略两者之间包括的文字。 Scriptlet中的一些类似于out和request的对象，转译成Servlet之后会对应到Servlet中的某个对象，request对应HttpServletRequest，像request和out的对象就被称为隐含对象。 pageContext转译后对应PageContext对象，提供了jsp页面资源的封装，page对应this out并不直接对应于有HttpServletResponse得到的PrintWriter对象，out对应JSPWriter对象，该对象模拟了BufferedWriter与PrintWriter的功能。jspWriter具有缓冲区功能，这时候就决定于页面是否具有缓冲区的功能了，如果没有则会立即输出，有的话只有在清空缓冲区才会输出，page指示元素的buffer属性设置缓冲区的大小，满了之后的行为采用autoFlush属性决定。 可以通过PageContext获得所有的隐含对象，除了封装所有的jsp页面信息之外 ，还可以使用pageContext来设置页面范围属性setAttribute、getAttribute、removeAttribute 在jsp页面中设置属性的方式有两种，一种是通过pageContext获得HttpServletRequest、ServletContext、HttpSession，另一种是利用pageContext统一提供的接口。getAttribute（String name，int Scope），setAttribute（String name，Object value,int scope）,remove(String name, int scope)，Scope是标识不同的范围，pageContext提供了findAttribute（），从页面，请求，会话到应用程序范围以此寻找。 错误页面使用page指示元素，设置errorPage属性便可以指定错误处理的JSP页面。错误页面的page指示元素的isErrorPage属性设置为true。 标准标签主要作用是减少scriptlet的使用，include指示元素可以把另一个JSP页面包含进来转移成一个Servlet类，无法在运行时动态调整想要的页面。如果想要在运行时依条件动态调整想要包括的JSP页面，则可以使用&lt;jsp：include&gt;标签，可以动态包括要给该页面的请求参数 转发页面可以使用&lt;jsp：forward&gt;，与前者的使用方法相同。 &lt;jsp:forward page=&apos;&quot;add.jsp&quot;&gt; &lt;jsp:param name=&quot;a&quot; value=&quot;1&quot;&gt; &lt;jsp:param name=&quot;a&quot; value=&quot;2&quot;&gt; &lt;/jsp:forward&gt; jsp:useBean、jsp:setProperty、jsp:getProperty JavaBean指的是满足以下条件的java对象，必须实现了Java.io.Serializable接口，没有公开的类变量，具有无参数的构造函数，具有公开的设值方法和取值方法，setter和getter，可以直接使用标签在页面中赋值 &lt;jsp:useBean id=&quot;名称（类实例变量名称）&quot; class=&quot;包名.类名&quot; scope=&quot;page、request、session、application&quot; type=&quot;想要指定的类型&quot;/&gt; &lt;jsp:setProperty name=&quot;类实例变量名&quot; property=&quot;属性值&quot;/&gt; setProperty标签的property为“*”时，表示将自动寻找符合JavaBean中设值方法名称的请求参数值，如果请求参数的名称为xxx，就将请求参数值使用setXxx（）方法设置给JavaBean实例。 在jsp中就可以写直接 调用id.方法（），赋值可以直接写&lt;jsp:getProperty name=”变量名” property=”属性名”&gt; 赋值的时候可以通过&lt;jsp:setProperty name=”user” property=”password” value=”123456”/&gt;","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"jsp","slug":"Jsp","permalink":"http://yoursite.com/tags/Jsp/"}]},{"title":"20171226","slug":"20171221","date":"2017-12-26T01:54:40.000Z","updated":"2017-12-22T06:34:22.116Z","comments":true,"path":"2017/12/26/20171221/","link":"","permalink":"http://yoursite.com/2017/12/26/20171221/","excerpt":"","text":"JSPJSP和Servlet是一体两面，jsp最后还是会被容器转译为Servlet，自动编译成.class文件，载入.class文件然后生成Servlet对象。JSP出错的时候可以查看Servlet代码发现错误 不同的web容器对于JSP的转译方式是不同的，jsp转变成Servlet之后会调用_jspInit()，_jspdestroy()。一般情况下不会重写这些函数，如果想要在jsp初始化的时候做一些事情，可以选择重写JSPInit（）和jspDestroy（）。 指示元素&lt;%@ 指示类型 [属性=“值”] %&gt;（[属性=“值”] 是正则表达式） 常用的指示类型：page（告知容器如何转译目前的jsp网页）、include（将其他的jsp页面包括进来进行转译）、taglib（告知容器如何转译这个页面中的标签库） include将其他页面包含的时候是一种静态的包含方式，就是把包含的文件直接拼接在一起。 声明在&lt;%!与%&gt;之间声明的程序代码，都将转译为Servlet中的类成员或者方法。也就是说把所有的成员变量声明和方法声明的java代码都写在这个&lt;%!与%&gt;之间，容器会使用同一个Servlet来服务不同用户的请求，每个请求就是一个线程，声明 变量的时候必须小心数据共享与线程安全的问题，使用该方法声明的变量是类成员变量，JSPInit（）和JSPDestroy（）就需要使用这种方式重写。 Scriptlet元素&lt;% java语句 %&gt;所有的内容将被转译到Servlet源代码中的_JSPService（），可以利用java语句的注释方式进行注释（//或者/········/) 表达式元素&lt;%= java 表达式&gt;表达式元素不用加分号，表达式元素中的表达式会直接转译成out对象输出时的指定内容。 因此在jsp中输出&lt;%或者%&gt;符号，要将角括号置换为替代字符，&lt;%可以换成&lt;% ，%&gt; 可以换成%&gt;或者%>。","categories":[],"tags":[]},{"title":"20171219","slug":"20171219","date":"2017-12-15T06:54:44.000Z","updated":"2017-12-22T06:34:22.116Z","comments":true,"path":"2017/12/15/20171219/","link":"","permalink":"http://yoursite.com/2017/12/15/20171219/","excerpt":"","text":"HttpSessionHttpServletRequest的getSession获得HttpSession对象，getSession可以加布尔类型的参数，默认为true，表示如果request没有HTTPSession的话就直接建立一个新的实例，若传入false，表示若尚未存在HttpSession实例，则直接返回null 如果想要在浏览器与web应用程序的会话期间，保留请求之间的相关信息，则可以通过使用HttpSession的setAttribute方法将相关信息设置为属性。 HttpSession的invalidate（）方法可以直接使目前的HttpSession失效，可以用来实现注销机制。 浏览器默认将SessionID存放在本地的cookie中，Cookie会在浏览器请求应用程序的时候被发送到应用程序。Web容器存储SessionId 的Cookie被默认设置为关闭浏览器就会失效，所以重新打开浏览器请求应用程序的时候通过getSession获得是新的HttpSession对象，如果浏览器没有被关闭，那么每次请求来到应用程序的时候容器会根据SessionID取得相应的HttpSession。可以使用serMaxAge（）来设置Cookie的有效期限 Session的另一种实现方式是URL重写，服务器向浏览器响应一段超链接，超链接URL后附加SessionID，当用户点击超链接时，则将SessionID以GET请求方式发送给Web应用程序。response.encodeURL协助产生所需的URL重写，如果禁用Cookie的话，encodeURL会自动产生带有SessionID的URL重写。 HttpSession用于当次会话阶段的状态维持，如果有相关的信息希望在关闭浏览器后，下次打开浏览器请求web应用程序时，仍然可以发送给应用程序，则需要使用Cookie。 执行HttpSession的setMaxInactiveInterval（）方法，设置的是HttpSession对象在浏览器多久没活动就失效的时间，而不是保存SessionID的cookie失效的时间 过滤器Servlet的生命周期大概是init（）、service（）、destroy（）,service决定要调用什么函数响应浏览器的响应。过滤器（Filter）位于Servlet之前，可以拦截过滤浏览器对Servlet的请求 实现Filter接口，Filter接口有三个要实现的方法init（）、dofilter（）、destroy() web.xml中定义过滤器对象时设置了初始参数，可以通过FilterConfig的getInitParameter方法来获取初始参数，设置参数和Servlet很类似，都是在声明的时候在一个init-param 当请求来到容器，容器发现了调用了servlet的service方法之前，可以应用某个过滤器，就会调用该过滤器的dofilter方法，然后决定是否调用FilterChain的doFilter方法。 //service()前置处理 chain.doFilter(request,response); //service（）后置处理 FilterChain执行过后会以堆栈顺序返回 &lt;filter-mapping&gt; &lt;filter-name&gt;PerformanceFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/index&lt;/url-pattern&gt;哪些URL请求将应用此过滤器 &lt;servlet-name&gt;SessionDemo&lt;/servlet-name&gt;或者是通过这个来指定Servlet名称，表示哪些Servlet将应用到此过滤器上 &lt;/filter-mapping&gt; 如果想要一次性符合所有Servlet名称，则可以使用 *号 触发过滤器的时机，默认是浏览器直接发出请求，如果是通过RequestDispatcher的forward和include的请求，则可以在web.xml中设置dispatcher标签，指定那些请求转发类型可以触发过滤器。 &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt; &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; 过滤器可以进行一些前置和后置处理，在service方法执行前改变请求对象的信息，或者改变响应，就需要利用封装器Wrapper，HttpServletRequestWrapper中实现了HttpServletRequest的getParameter方法，可以把requestWrapper当作request使用。 响应封装器对浏览器进行输出响应，必须通过getWriter获得PrintWriter或者getOutputStream获得ServletOutputStream两种方法，针对压缩输出的需求，主要是继承HttpServletResponseWrapper之后，重写这两个方法。 监听器Servlet/JSP中的监听器可以分为三个类别 生命周期监听器在某个对象生成到被容器销毁之前，监听对象生命周期的状态改变 ServletContextListener： contextInitialized（）与contextDestroyed（），通过传入的ServletContextEvent取得ServletContext。 ServletRequestListener： RequestInitialized（）与RequestDestroyed（），通过传入的ServletRequestEvent取得ServletRequest。 HttpSessionListener： SessionInitialized（）与SessionDestroyed（），通过传入的HttpSessionEvent取得HttpSession。 ##属性操作监听器 ServletContext、HttpSession、ServletRequest，对象的属性发生变化时进行一些动作，监听器的参数XxxxxxEvent代表事件，有getName和gatValue的方法 ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener HttpSessionAttributeListener的事件名称是HttpSessionBindingEvent ##会话属性类监听器（不需要在web.xml中声明） 如果有个即将加入HttpSession的属性对象，希望在成为HttpSession或者被删除的时候得到通知，需要实现HttpSessionBindingListener，属性被加入到HttpSession或从中删除的时候，就会调用对应的valueBound与valueUNbound方法，并传入HttpSessionBindingEvent HttpSessionActivationListener的主要作用在于将HttpSession从一个JVM迁移到另外一个的时候需要序列化，如果一个对象实现了这个监听器，在序列化的时候就会调用sessionWillPassivate，反序列化的时候调用sessionDidActivate 在web.xml中对于servlet进行设置的时候，可以添加标签load-on-startup，表示在应用程序启动的时候就将servlet进行实例化并做好初始化 设置 完全符合模式：以斜杠开头，从web应用程序环境的根目录开始，指定完整的URL模式 目录符合模式：以目录开头，之后加星号，某个目录下的所有URL都交由某个Servlet处理。”/guest/*” 扩展名符合模式：以某个扩展名为结尾的所有URL请求，都交由对应的Servlet处理，可以使用星号作为开头.“*.do” 如果url请求在模式有重合的时候，按照从1到3的顺序 welcome-file-list标签中使用来设置默认欢迎界面，不能以斜杠开头，如果浏览器请求的/hhh/user不存在的时候，容器会按照welcome-file-list的顺序依次打开/hhh/user/（welcome-file中包含的文件），找不到的时候会到上一层/hhh去寻找/hhh/（welcome-file中包含的文件）。 如果发生错误的时候又没有处理，容器会直接显示错误信息，可以通过在web.xml中设置error-page进行设置。error-page的标签里还可以使用exception-type和location的组合来决定不同的type去往不同的错误界面，如果想要把http的错误状态码发送到处理页面，还可以加入error-code标签 为了让浏览器知道如何处理收到的串流数据，需要告知MIME类型，如果在web.xml中设置了mime-mapping，则可以通过ServletContext的getMimeType（）方法获取MIME类型，这个方法的参数是文件名称，自动匹配对应的扩展名","categories":[],"tags":[]},{"title":"20171211","slug":"20171211","date":"2017-12-11T09:04:12.000Z","updated":"2017-12-22T06:34:22.116Z","comments":true,"path":"2017/12/11/20171211/","link":"","permalink":"http://yoursite.com/2017/12/11/20171211/","excerpt":"","text":"最近太忙了，期末了各种作业. 客户端也可以通过js进行窗体验证，用来节省服务器的运算资源，但是客户端验证只针对格式等与安全无关的部分进行验证，用户可以选择跳过客户端窗体验证。 利用forward（）请求转发的时候浏览器并不知道在服务器上发生了转发，可以获得WEB_INF中的数据，sendRedirect（）要求浏览器重定向请求其他的数据，这个函数可以使用相对或者绝对URL 在使用sendRedirect（）的时候，最好使用绝对路径，比如说http://localhost:8080/exercise/index,我们现在想利用该函数到某个页面，在该页面的前面加上当前web应用的上下文路径，也就是exercise 请求转发(forward)Servlet（源组件）先对客户请求做一些预处理操作，然后把请求转发给其他Web组件（目标组件）来完成包括生成响应结果在内的后续操作；请求包含(include)Servlet（源组件）把其他Web组件（目标组件）生成的响应结果包含到自身的响应结果中； 转发和包含路径 以“/”开头：相对当前项目路径，即默认为http://localhost:8080/项目名/ 不以“/”开头：相对当前Servlet路径。eg:在Aservlet中写“Bservlet”，Aservlet的路径为： http://localhost:8080/项目名/servlet/Aservlet ，那么Bservlet的路径为：http://localhost:8080/项目名/servlet/Bservlet 重定向路径（客户端路径）： 以“/”开头：相对当前主机（端口号之后），即默认为http://localhost:8080/ 不以“/”开头：相对当前Servlet路径 ServletConfig是容器根据web.xml的内容生成的Servlet的设置的实例对象，和每一个Servlet对应，在实例化Servlet的时候，容器还没有调用init（）方法传入ServletConfig，所以不会有servletConfig实例，也就是说ServletConfig必须在web容器将Servlet实例化以后，调用有参数的init（）方法再将之传入，所以在继承HttpServlet后通常会重写无参数的init（）方法【最适合读取初始参数的地方】来获取Servlet的初始参数。 初始参数通常用作常数来设置，可以将一些Servlet程序中不想写死的信息放到初始参数中，一个定义一组和 ServletContext是整个web应用程序运行后的代表对象，通过ServletConfig的getServletContext（）方法来获得，之后就可以利用ServletContext来取得web应用程序的相关资源或信息 以“/”开头的路径称为环境相对路径，没有以“/”作为开头则称为请求相对路径 getResourceAsStream()的参数路径必须以“/”作为开头，表示相对应于应用程序环境根目录，运行结果会返回InputStream实例，如果在java EE中使用java.io下的File、FileReader等等与文件读取相关的类时，可以指定绝对路径和相对路径，绝对路径是文件在服务器上的真实路径，相对路径相对的是启动web容器时的命令执行目录，比如说Tomcat的根目录 ServletContextListener可以知道web应用程序何时初始化或者何时结束销毁，并在web.xml中设置告知web容器，在web应用程序初始化后或者即将结束销毁之前，调用ServletContextListener实现类的相对应的contextInitialized（）或contextDestroyed()。{在web.xml中配置某个Servlet的Listener，并且重写这个listener的contextInitialized（）} 在整个web应用程序生命周期内，Servlet所需共享的数据可以设置为ServletContext属性 会话管理：此次请求和之后请求的关系 隐藏字段 服务器不会记得两次请求之间的关系，需要浏览器在每次请求的时候告诉服务器这些请求之间的关系，服务器只需要处理就好了。服务器把上一次请求的结果以隐藏字段的方式存储在下一页的窗体中响应给浏览器，然后浏览器把上一次的结果和这一次的结果都发给服务器具体使用是 “&lt;input type=”hidden” name=”” value=””> “，但是右键查看源码是可以看见这些隐藏字段的值，所以不适合用于隐秘性 较高的数据。 Cookie的使用 Cookie类，使用HttpServletResponse的addCookie（）方法在响应中添加Cookie，setMaxAge（）可以用来设置Cookie的有效期限，利用HTTPServletRequest的getCookies（）方法可以获得该网页所属域的所有cookie，cookie类的getName和getValue方法可以用来取得cookie的值 getAttribute（）获取的是request在web容器内部转发的数据，而getParameter（）获取的是从web客户端传送来的数据 URL重写的使用 get请求参数的应用，当服务器响应的浏览器的上一次请求时，将某些相关信息以超链接方式响应给浏览器，get请求参数长度有限，因此大量的客户端信息保留并不适合使用URL重写。","categories":[],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/后台/"}]},{"title":"20171201","slug":"20171201","date":"2017-11-24T07:58:38.000Z","updated":"2017-12-22T06:34:22.116Z","comments":true,"path":"2017/11/24/20171201/","link":"","permalink":"http://yoursite.com/2017/11/24/20171201/","excerpt":"","text":"写在前面在学习Servlet和JSP的过程中书里面要求开发一个在线书签。 java中常用的输入输出流 字节流 FileInputStream BufferedInputStream DataInputStream |||| FileOutputStream BufferedOutputStream PrintStream 字符流 BufferedReader FileReader ||||||BufferedWriter FileWriter PrinterWriter 使用HttpServletResponse的sendRedirect（）可以要求浏览器重新请求另一个URL，又称为重定向，使用时可指定绝对URL或者相对URL，和Dispatcher 的forward不一样，forward是服务器自己跳转，而sendredirect是让浏览器跳转 可以通过在servletReuqest通过setAttribute（）设置属性，该对象只在此次请求范围内有效，在请求/响应之后该对象会被销毁 同一个请求周期中，HttpServletResponse的getWriter（）和getOutputStream（）只能使用一个","categories":[],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/后台/"}]},{"title":"20171120","slug":"20171120","date":"2017-11-20T13:32:53.000Z","updated":"2018-03-13T03:15:17.002Z","comments":true,"path":"2017/11/20/20171120/","link":"","permalink":"http://yoursite.com/2017/11/20/20171120/","excerpt":"","text":"http中get请求一般用于幂等操作（请求数据但不改变服务器上的数据），post用于非幂等操作（改变服务器上的数据，上传文件等），过长的请求参数也需要使用post 容器是java的一个应用程序，负责和服务器沟通，容器会把jsp网页转译成Servlet，加载到容器中进行管理，最后的所有jsp都会以servlet的实例中存在于容器中。每次有请求进来时，都是使用同一个容器进行处理，由容器开启一个线程，并决定是哪个Servlet来处理，如果有多个请求就启动多个线程来处理 当请求来到http服务器的时候，服务器将请求转交给容器，容器会根据请求的参数建立一个代表当次请求的httpServletRequest对象，同时创建一个httpServletResponse对象，接着根据web.xml的设置，找出处理该请求的Servlet，调用他的service方法初始化。 对于 http://localhost:8080/FirstServlet/hello.do?name=cate 来说，web容器会根据请求的逻辑名称（在前面这个链接就是hello.do来查找哪个Servlet可以处理这个链接的请求），找到Servlet之后根据servlet的名字和物理类名称的对应关系处理请求，调用Servlet的service（）方法，将所创建的HttpServletRequest对象和HttpServletResponse对象传入作为参数，service（）方法会根据http请求的方式调用不同的方法 不要在Servlet程序中夹杂着HTML的页面输出，JSP网页中的HTML中也不要夹杂Java程序逻辑 MVCMVC就是Model，View，Controller Model负责控制逻辑部分，View负责与用户的页面交互，Controller负责收集用户请求，并转发给相对应的模型 MVC模型中，http服务器没办法在服务器状态更新的情况下要求浏览器主动查询更新页面（http是基于请求响应的通信协议）在Web应用程序中，将MVC模型经过更新形成Model 2架构 控制器收集请求相关信息，并不从事业务逻辑处理Servlet，控制器只顺序调用函数实现跳转模型通常是一个纯粹的java对象 ，页面的逻辑都在java对象中实现视图进行页面的组织，由JSP技术实现 html页面中\\n不能正常显示，要换行必须要页面中用&lt;br>&lt;/br>包含 Http请求、响应处理http请求中的所有信息都封装在HttpServletRequest中，这个接口实现了ServletRequest接口 浏览器接受到相应的html必须知道怎么正确解释文字编码，HttpServletResponse有一个setContentType的方法可以设置，除此之外也可以使用字符串的getbytes方法重新编码字符串。 利用下面的方法可以实现跳转请求，由其他的servlet和jsp负责处理，其中的request和response可以通过ServletRequeatWrapper、ServletResponseWrapper或者其子类将容器产生的request和respond重新包裹 request.getRequestDispatcher(&quot;相对url&quot;).forward(request, response) 在执行forward（）之前不能给浏览器确切的回应。执行完forward还会回到原来的servlet/jsp，但是没有办法继续响应（http协议的特性） 如果打算在目前的servlet/JSP中进行一些对浏览器的响应，而中间想将其他Servlet/JSP包括进来回应，则可以执行RequestDispatcher的include（）方法 写在后面突然感觉自己好像有点啰嗦，我看书的时候把一些小点记在博客上，但是感觉打字太慢，所以以后需要降低在博客上记载书上已有知识的篇幅","categories":[],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/后台/"}]},{"title":"20171114","slug":"20171114","date":"2017-11-14T01:21:07.000Z","updated":"2017-12-22T06:34:22.101Z","comments":true,"path":"2017/11/14/20171114/","link":"","permalink":"http://yoursite.com/2017/11/14/20171114/","excerpt":"","text":"触发器触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。 CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt1 其中： trigger_name：标识触发器名称，用户自行指定；trigger_time：标识触发时机，取值为 BEFORE 或 AFTER；trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE；tbl_name：标识建立触发器的表名，即在哪张表上建立触发器；trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句。 由此可见，可以建立6种触发器，即：BEFORE INSERT、BEFORE UPDATE、BEFORE DELETE、AFTER INSERT、AFTER UPDATE、AFTER DELETE。 另外有一个限制是不能同时在一个表上建立2个相同类型的触发器，因此在一个表上最多建立6个触发器。 select语句返回的是结果集，就算最终的结果是表中的一个具体部分，也是一个结果集 查看触发器show triggers 查看数据库中所有的触发器 select * from information_schema.triggers where trigger_name = ’触发器名称‘ 视图（view）数据库中只存放了视图的定义，没有视图的数据，所以每次使用视图获得的都是最新的数据，主要作用是保证了应用程序和数据库表的逻辑数据独立性，以及安全性新建视图前先检查是否具有权限。 create [ or replace] [algorithm=[undefined | merge | temptable ]] view 视图名（属性清单） as select语句 [with [CASCADED | LOCAL ] check option]; or replace的意思是如果存在的话进行修改，如果不存在的话创建视图 algorithm表示视图选择的算法 with check option是可选参数，表示更新视图时要保证在该视图的权限范围内。创建视图时指定了witch check option关键字，这也就是说，更新后的每一条数据仍然要满足创建视图时指定的where条件。通过视图进行的修改，必须也能通过该视图看到修改后的结果如果有with check option的话，默认关键字是cascade select语句中不能包含from子句中的子查询 不能将触发程序和视图关联在一起。 视图是建立在数据库上的 查看视图 DESCRIBE（desc）视图名； show table status like ‘视图名’；(不带like就是展示目前数据库中的表和视图) show create view 视图名； 修改视图 create or replace 和定义时类似，将create改成alter create [ or replace] [algorithm=[undefined | merge | temptable ]] view 视图名（属性清单） as select语句 [with [CASCADED | LOCAL ] check option]; 更新视图（insert、update） 由于视图是一个虚表，所以通过视图的更新都将通过转化为基本的表操作，更新时必须保证拥有权限，更新时将视图看做普通的表。 有几种情况更新视图是不能成功的。 视图中包括了count、sum、max、min等函数 视图中包含了union、UNION all 、distinct、group by、having等关键字 select中包含了常量或者有子查询。 由不可能更新的视图产生的视图。 创建视图时算法为temptable类型。 视图对应的表上存在没有默认值的非空列，并且这一列也不在视图中，所以插入失败。 drop view if exists 视图名 [restrict | cascade ] 事务（transaction）ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） start transaction；后面紧跟由begin和end包含的一些sql语句commit提交事务，rollback回滚事务。事务不支持嵌套功能 自动提交：autocommit，该变量为1时自动向数据库提交结果，用户在操作数据库的时候不需要start transaction等，如果设置为0，则需要用户输入commit才会将数据表中的资料提交到数据库中(set autocommit=0)； 事务的孤立级：不同的用户通过不同的会话执行不同的事务，为了保证事务互不影响，保证数据库性能不受到影响，采用事务的孤立级是十分必要的。 MySQL提供4种孤立级：serializable（序列化）以序列的形式对事务进行处理，只有当事务提交后用户才能从数据库中查看数据的变化repeatable read（可重读 ）不会被看成序列，提交之后才能看到结果read commited（提交后读）用户可以看到其他事务添加的新记录，在同一事务的不同时间内，应用查询语句可能会得到不同的结果read uncommited（未提交读）容易产生虚幻读操作，其他用户可以在该孤立级上看到未提交的事务。 修改事务的孤立级：（set 事务名 transaction isolation level 孤立级；）select @@tx_isolation； MySQL伪事务MyISAM类型表不支持事务，所以采用表锁定替代事务 lock tables 表名 lock_type； unlock tables； lock_type包括只读和只写 其他相关知识数据库备份备份一个数据库中的若干表 mysqldump -u username -p 数据库名 数据表名 (可以是多个表，没有该参数默认备份整个数据库) &gt; 备份文件名.sql 备份多个数据库 mysqldump -u username -p --databases 数据库名1 数据库名2 &gt;备份文件名.sql 备份所有数据库 mysqldump -u username -p --all -databases &gt; 备份文件名.sql 数据库查询的时候利用索引会加快查询速度，可以用explain和describe来分析查询语句，之后可以看到查询所需要的查询行数 插入记录时，索引和唯一性校验都会影响到插入记录的速度 alter table 表名 disable keys； alter table 表名 enable keys； 唯一性校验set unique_check=0/1; 分析、检查、优化表analyze/check/optimize table 表名 如果一个表中使用了TEXT或者BLOB这样的数据类型，那么更新删除等操作就会造成磁盘空间的浪费，所以需要使用optimize进行优化","categories":[],"tags":[]},{"title":"正则表达式","slug":"正则","date":"2017-11-09T01:41:46.000Z","updated":"2017-12-22T06:34:22.116Z","comments":true,"path":"2017/11/09/正则/","link":"","permalink":"http://yoursite.com/2017/11/09/正则/","excerpt":"","text":"写在前面正则表达式一直是一个我搞不懂的点，虽然我知道他是用来字符串匹配的，但是各种符号的使用总是没搞明白，想着自己搞一遍但是我写博客肯定费劲，先看吧，看完再说。 正文","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"数据库","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"20171107","slug":"20171107","date":"2017-11-07T01:08:52.000Z","updated":"2017-12-22T06:34:22.101Z","comments":true,"path":"2017/11/07/20171107/","link":"","permalink":"http://yoursite.com/2017/11/07/20171107/","excerpt":"","text":"mysql有三个比较常用的存储引擎，存储引擎就是定义如何存储数据，如何为存储的数据建立索引和如何更新查询数据等具体问题的技术实现，“show engines；”比较常用的存储引擎有三个：InnoDB、MyISAM、MEMORY。 InnoDB：可以实现事务处理，支持外键，频繁的更新删除操作可以选用。 MyISAM：管理非事务表， 占用空间小，处理速度快，主要用于插入新记录和读出记录。 MEMORY：该存储引擎所有数据都在内存中，处理速度高，但是安全性不高，只能适用于相对较小的数据库 如果要搜索的内容不区分大小写，可以使用TEXT类型。如果要搜索的内容区分大小写，可以使用BLOB类型。 在SQL中null不能用=来判断，“=”能判断的字符串相等都是根据ASCII码。如果相等返回1，不相等返回0； NULL值可以用运算符（IS NULL和IS NOT NULL） NULL和‘NULL’不一样，一个是空值，一个是字符串 BETWEEN AND技术就是在某个取值范围之内，IN用于判断数据是否存在于某个集合之中。LIKE用来匹配字符串，x1 LIKE s1，如果x1与字符串s1匹配成功，结果将返回1，否则将返回0。REGEXP用于字符串的正则匹配 &amp;&amp;和“AND”作用一致，除了返回0和1之外，当一个数据为NULL并且没有数据为0，则结果返回NULL。或运算与之相似。 非运算“NOT”和“！”返回与操作数相反的结果，如果是非0数字，结果返回0；如果操作数是0，则返回1，如果操作数是NULL，结果返回NULL 异或运算符也是一样，如果其中一个为NULL，那么最后的结果也是NULL。 位运算符有6种，“&amp;“、”|“、”~“(按位取反)、”^”、”&lt;&lt;”、”&gt;&gt;“ 常用sql语句 create\\drop database 数据库名； use 数据库名（设置默认数据库）； 列名 类型 [not null | null] [DEFAULT value] [auto_increment] [primary_key] [reference_definition] alter table 表名 {具体操作，没有大括号，用逗号可以多个动作连续操作，add，drop，modify，change， rename }；modify和change没有特别大的区别。最后可以加上after|first 列名的关键字，表示这一列将会在哪一列前面或者后面。 SELECT查询中，distinct去除重复行，like模糊查询，like只有两个通配符”%”和”_”，前者可以匹配一个或多个字符，后者只匹配一个字符。limit限制输出的记录条数。 update 表名 set 列名=新值 where 条件。 delete from 表名 where condition 条件判断函数 IF（expr，v1，v2） IFNULL（v1，v2） CASE WHEN expr1 THEN v1 [WHEN expr2 THEN v2] [ELSE vn] END CASE expr WHEN e1 THEN v1[WHEN e2 THEN v2] [ELSE vn]END select id,user,case when strcmp(email,&quot;@1995&quot;)=0 then &apos;good&apos; when strcmp(email,&quot;LL1192759422@163.com&quot;)=0 then &apos;very good&apos; else &apos;normal&apos; end level from tb_admin; sql中条件语句不需要写双等号，判断当某个式子是否成立 字符串常量一定要记得加引号 查询语句select selection_list from 数据表名 where primary_constraint group_by grouping_columns order_by sorting_columns having secondary_constraint limit count 这个里面关键词的顺序是固定的 一些SQL内置的函数只能用在selection_list中。 IN，BETWEEN AND，LIKE，IS NULL，AND，OR都是用在where中的 distinct去除重复记录，select distinct 字段名 from 表名 连接查询内连接查询 最正常的查询方式，两个表里有相等的部分。 外连接查询 左外连接 右外连接 全外连接 外连接就是将数据进行混合，左外连接就是将左表中每一条数据分别与右表中每条数据进行连接组合，返回的数据除了内连接的数据还包括了左表中不符合条件的数据，并在右表的相应列中增加null值，简单来说就是左外连接最后返回的结果中必须包含左表的所有数据。右外连接亦然。 select 字段名称 from 左表 left||right join 右表 on 表名1.字段名=表名2.字段名 where conditions IN关键字（集合）EXISTS关键字（返回真或假）ANY关键字（any（）表示括号内数据的任意一个）ALL关键字（和ANY用法类似）AS关键字（用来给字段起别名）UNION和UNION ALL将两个select语句的结果合并在一起，二者区别在于不带all会去除重复记录。正则匹配中只有匹配字符集合时用到了方括号","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"数据库","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"20171105","slug":"20171105","date":"2017-11-01T02:45:26.000Z","updated":"2017-12-22T06:34:22.101Z","comments":true,"path":"2017/11/01/20171105/","link":"","permalink":"http://yoursite.com/2017/11/01/20171105/","excerpt":"","text":"先交代一下上周没写博客，是因为上周忙着搞理论工作了，没时间实践了，全部都是无聊的看论文，无fuck可说，因此没写，这周继续学习JavaScript，还有mysql，mysql主要是熟悉一下基本操作，然后就是关于他的高级编程的部分。 正文本来之前过一点点html的书，对html有简单的了解，但现在发现html的正常使用以及CSS样式表也是非常关键的一部分内容，只能在学习的过程中不断接触了。 Cookie这个东西简单来说是用来在本地存储一些信息，减轻服务器的压力。Cookie里面的信息保存是内容累加的，各段内容之间由分号隔开，cookie里面的键值对就是key=value，比如说 document.cookie=”a”; document.cookie=”b”; document.cookie=”key=value”;最终cookie里面的内容就是“a；b；key=value”，cookie中有一些编码的限制（保存的内容中不能出现“=”和“；”），所以JavaScript提供了内置的编码和解码函数，用来将非英文的字符编码或者解码，编码函数和解码函数分别为escape和unescape。cookie有自己的生命周期，利用“expires=过期日期字符串”","categories":[],"tags":[]},{"title":"20171019","slug":"20171019","date":"2017-10-16T02:12:08.000Z","updated":"2017-12-22T06:34:22.101Z","comments":true,"path":"2017/10/16/20171019/","link":"","permalink":"http://yoursite.com/2017/10/16/20171019/","excerpt":"","text":"volatile关键字有两个作用：一个是保证所修饰的变量的更改对所有使用他的进程都可见；另一个是禁止优化时的指令重排序。volatile保证了多线程操作时变量的可见性，并不能保证原子性，如果要对volatile变量进行运算，就需要同步。 java的双亲委派模型，启动类加载器（Bootstrap ClassLoader），扩展类加载器（Extension ClassLoader），应用程序类加载器（Application ClassLoader），自定义类加载器（User ClassLoader），前者是后者的父加载器，应用程序类加载器负责加载用户类路径（Classpath）上所指定的类库。 CAS操作是指当且仅当内存位置V符合旧的预期值A时，处理器才会用新值B更新V 的值，否则他就不执行更新，但是无论是否更新了V 的值，都会返回V的旧值。 17号早上《深入理解java虚拟机》这本书基本上看完了，第四部分没看，第四部分是程序编译与代码优化，具体内容是早期编译期优化和晚期运行期优化，最终也就是第四章，第五章，第九章没有看。看完之后可能还是有点懵逼，有一些部分还不是很清楚，但总算是了解了一些，今天刚好有点时间，总结一下这本书里大概学到的知识点。 java内存区域和内存溢出异常：每次打开一个java程序就会打开一个java虚拟机实例，也就是每一个运行main函数就会生成一个java虚拟机的实例，这每一个java虚拟机上运行的每一个线程都有自己的程序计数器，虚拟机栈和本地方法栈。程序计数器是当前程序运行的字节码的行号指示器，虚拟机栈和本地方法栈简单来说一个运行的是java方法，一个是本地的方法，也就是JNI方法，java的每一个方法都是以栈帧的方法执行的（栈帧的内容就是局部变量表、操作数栈、动态链接、方法返回地址）。堆和方法区是共享部分，java堆中都是新建的对象实例，但是只有存储的数据，对于里面数据的解读则要到方法区中查询。方法区中存储的是被虚拟机加载的类信息，常量和静态常量、即时编译器编译后的代码等数据，方法区中有运行时常量池，用于存放编译器生成的各种字面量和符号引用 垃圾收集器和内存分配策略：【哪些内存需要回收？什么时候回收？如何回收？ 判断内存需要回收使用的算法是引用计数算法和可达性分析算法，java使用的是可达性分析算法（GC roots 的选取），回收的时间选择安全点或者安全区，就是在这部分区域里进行垃圾回收。垃圾收集算法一共有三种，复制算法，标记整理算法和标记清除算法。垃圾收集器的种类：Serial收集器（新生代复制算法），Serial Old（老年代标记整理算法）、ParNew收集器（Serial收集器的多线程版本）Parallel Scavenge收集器（新生代收集器，与CMS的不同在于控制吞吐量，而不是缩短停顿时间）Parallel Old收集器（Parallel Scavenge的老年版本）Parallel Scavenge只能和Serial Old、Parallel Old搭配，CMS收集器和G1收集器】【对象在堆上分配，堆上有一个Eden和两个Survivor，对象优先在Eden上分配，大对象直接进入老年代、长期存活的对象将进入老年代、动态对象年龄判定】 类文件结构以及类加载机制：每个class类文件都需要被加载，加载的时候就按照类文件里的定义直接加载到方法区中。类文件里对于每个模块的定义以及内容之间的联系。这部分内容有自定义的类加载器以及双亲委派模型和双亲委派模型被破坏的情况。 java内存模型与线程安全：java的主内存和线程的工作内存，工作内存之间的数据交换只能通过主内存，java内存模型在执行时必须满足一些特定的规则【不允许一个变量从主内存读取但工作内存不接受、从工作内存发起回写但主内存不接受、变量在发生了更改之后必须把该变化同步到主内存中、不允许毫无理由的把工作内存中的数据同步到主内存、新变量只能在主内存之中产生、一个变量同一时刻只允许一条线程对其进行lock操作、对一个变量执行lock操作将会清空工作内存中 的值、没有被lock就不能被unlock、执行unlock操作之前必须把此变量同步回主内存中】线程安全的实现方法包括利用Synchronized和ReentrantLock【自旋锁、自适应自旋锁、轻量级锁、偏向锁】","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"}]},{"title":"20171009","slug":"20171009","date":"2017-10-09T03:14:13.000Z","updated":"2017-12-22T06:34:22.101Z","comments":true,"path":"2017/10/09/20171009/","link":"","permalink":"http://yoursite.com/2017/10/09/20171009/","excerpt":"","text":"今天开始每天一道leetcode，今天这道题做的让我怀疑人生，虽然好像是学习了很多javaSE的知识，但还是什么都不会，一写程序的时候就只会数组。真的是服了我自己了，还是代码写的太少，今天的这道题目是two sum，就是从数组中找到给定的数的两个加数，我自己的方法就是先排序，然后去寻找目标数的位置，然后从前往后减，这种方法在全部都是正数的情况下复杂度比较低，如果是有负数的话就会比较复杂，然而最简单的方法看完之后就开始怀疑人生了。。。用了一种很巧妙的方法，是那种我自己从来不会想到的方法。从那天过后，这几天过的真是更累，以后每周例会要讲一个ppt，也就是我每周至少要看一篇论文，然后又做了助教，帮老师做ppt，就是感觉自己做事效率太低，而且这样的生活和我想象的研究生生活也不太一样了，这周就做了一道题。之前的那个我想做的android的仿qq项目也感觉要无疾而终了，自己的时间不太够用，也许是我现在还是比较懵逼，不知道自己想要什么，如果是想做一个合格的java程序员为什么要去搞这个，总想着什么都会，到最后什么都不会，以后的主营方向是java，还要学习一下Python，直接进入Python的实战编程阶段了，还想要学习一下JavaScript，但是感觉自己的时间都被狗吃了。。。不知道为什么没有成就感，周末还要加班搞一下两个ppt和一些知识点。先立flag，要学的是JavaScript和Python，Python先写一个比较简单的爬虫，JavaScript还需要看书，起码要做到简单的界面，因为我现在还处在没入门的阶段，每天用java做一道LeetCode，背单词，健身，跑步。每天晚上花两个小时来学习吧。。。时间感觉真的很少。就这样吧，这周的这篇博客就水过去了，没什么干活。","categories":[],"tags":[{"name":"随笔","slug":"Essay","permalink":"http://yoursite.com/tags/Essay/"}]},{"title":"20170926","slug":"20170926","date":"2017-09-23T02:19:44.000Z","updated":"2017-12-22T06:34:22.101Z","comments":true,"path":"2017/09/23/20170926/","link":"","permalink":"http://yoursite.com/2017/09/23/20170926/","excerpt":"","text":"额，我又隔了一周，这个周周发博客的flag要倒塌了，这周主要在看的书仍然是《深入理解java虚拟机》， 虚拟机运行的时候，内存中 有这么几部分： 方法区，堆，虚拟机栈和本地方法栈，程序计数器。 程序计数器肯定是线程私有的，因为单核cpu上执行的线程肯定要记录上一个时间片上自己执行到哪里了。 虚拟机栈和本地方法栈的区别在于虚拟机栈中执行的是java方法，而本地方法栈执行的是本地方法，也就是用JNI编写的方法，这里就要说到虚拟机栈和本地方法栈中的内容了，首先这两个栈肯定也是线程私有的，因为每一个线程都有自己调用的不同方法，虚拟机栈和本地方法栈中的最小单元是栈帧，栈帧也就是每一个方法产生的结构，每一个栈帧中都有局部变量表、操作数栈、动态连接和返回地址，局部变量表的最小单位是slot，一般情况下只有float和double需要两个slot存放，操作数栈也是，操作数栈和局部变量表的大小在java代码编译之后就已经写入class文件中了，动态连接的内容是运行时常量池这个方法的一个引用，因为在方法执行过程中可能需要动态连接，所以要在栈帧中保持这个信息，返回地址肯定是需要的，因为每一个栈帧代表一个方法，这个方法执行完成之后肯定需要回到原来的地方，所以就需要每个栈帧拥有自己的返回地址。 方法区和堆是线程共享的，方法区里面包含类的信息，版本，以及经过的编译的代码，方法区内部有运行时常量池，运行时常量池中存放着class编译期生成的各种字面量和符号引用所转变出来的直接引用，堆的主要内容是新建的对象，线程需要使用的时候，从堆里把内容拿出来，然后对照着方法区里类的格式区分堆里对象每一个部分代表的意义。 class文件中存放的是经过编译的内容，常量池，字段表，方法表，属性表。常量池里面是一些字面量和符号引用，字段表的主要内容是访问标志、名称索引、描述符索引、属性数量和属性值。方法表的内容也是和字段表差不多。另外一块内容是java的垃圾收集器和内存分配策略。java的GC机制算是java的一大特色了。垃圾回收主要有三个主要的问题，判断对象是否已经废弃，怎么回收，何时回收。 对象是否已死有两种办法，引用计数算法和可达性分析算法。引用计数算法是为每一个对象保留一个引用计数器，如果这个对象被引用就加1，被引用的对象被销毁就减1，不能解决相互引用的问题，比如说ab相互引用，但ab已经不会被用到了，所以就不能被回收。所以主流算法采用的方法都是可达性分析算法，一般选择GC Roots，当一个对象和GC roots之间不能可达的时候就说明这个对象已经死了。但是真正要回收一个对象所占的内存，还需要观察这个对象是否需要有必要执行finalize()方法，方法区也需要回收 垃圾回收算法有三个：标记清除算法。复制算法。标记清除算法；标记清除就是标记已死亡的内存然后直接清理。复制算法是有两块半区，一块满了就把所有未死亡的对象复制到另一块上，把原先的那块全部清除。。标记整理算法是把标记已死亡的内存都清理，然后把活着的对象都向一端移动，直接清除活着的对象之外的所有的内存。 算法执行在安全点或者安全区，安全点就是程序长时间执行的地方。 垃圾收集器的种类。","categories":[],"tags":[{"name":"笔记","slug":"Tips","permalink":"http://yoursite.com/tags/Tips/"},{"name":"java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"第二周学习成果","slug":"第二周学习成果","date":"2017-09-11T05:50:29.000Z","updated":"2017-12-22T06:34:22.116Z","comments":true,"path":"2017/09/11/第二周学习成果/","link":"","permalink":"http://yoursite.com/2017/09/11/第二周学习成果/","excerpt":"","text":"这一周的学习成果做个简单的记录吧，以后说不定还会看。 符号引用和直接引用（符号引用就是变量名这种间接访问的方式，直接引用就是分配在常量池中的东西） 内存泄露和内存溢出（内存溢出就是你想要的大小的内存系统不能分配给你，一旦分配给你就会发生溢出，内存泄露是指由于资源没有被正常释放，导致系统最后瘫痪。。。内存泄漏最终会导致内存溢出） 悲观锁和乐观锁（悲观锁就是锁被占用时，剩下的所有进程都需要等待） 并行和并发（并行是一并执行的意思，就是同时运行在不同的cpu上，同时执行；并发就是在一个cpu上执行，真正不能同时，因为一个cpu时间内只能执行一个进程） java虚拟机运行时数据区域分为以下几部分：一是程序计数器，线程私有，每一个线程都必须要有自己的程序计数器，虚拟机才能知道该线程已经运行到哪里了。第二个是本地方法栈和虚拟机栈，这两部分也是线程私有的，本地方法栈主要执行涉及到JNI 的方法，虚拟机栈是执行所有java方法的地方，每个java方法都是一个栈帧，不断地入栈出栈。第三个是方法区，这个部分里面就是所有的实质性内容，包括类的信息和一些编译后的代码，方法区是线程共享的，方法区包括所有被虚拟机加载的类等。最后一部分是堆，新建对象都存储在这里，但java虚拟机需要查询方法区才知道这个对象的数据里都是什么内容。 java的GC（垃圾回收）需要解决三个问题，哪些内存需要回收，什么时候需要回收，如何回收，判断是否需要回收一般使用引用计数算法和可达性分析算法，引用计数算法就是引用加1，引用失效减1，始终为0就说明已经可以回收（有缺陷），可达性分析就是选择GC roots，如果到GC roots没有可达的路径就说明可以回收。什么时候回收主要就是安全区和安全点，指令序列复用的地方就是安全点，安全区就是很多个安全点。。如何回收就涉及到垃圾回收算法，主要包括复制算法（有缓冲区和使用区，用完使用区之后把有效数据放在缓冲区，然后把当前正在使用的使用区清空，使用区变缓冲区，缓冲区变成使用区），标记整理算法（所有存活对象向一端移动，从端向右直接清空），标记清除算法（直接把无效数据区清空） 一些零碎的知识点： java中String的创建有两种方式，一种是使用new新建，另一种是直接用双引号定义，new新建的String变量在java Heap中，双引号声明的String变量在字符串常量池中，就是字符串的内容相同，他们的变量也不相同。","categories":[],"tags":[{"name":"java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"惭愧","slug":"20170911","date":"2017-09-11T02:19:03.000Z","updated":"2017-12-22T06:34:22.101Z","comments":true,"path":"2017/09/11/20170911/","link":"","permalink":"http://yoursite.com/2017/09/11/20170911/","excerpt":"","text":"嘻嘻惭愧啊，说好的每周最少一篇博客呢，回家待了两周多，学习的时间一分钟都没有，额，自然也就没什么博客的内容了，高中同学崔某还说我的自控能力特别强，哈哈哈哈，我自己都不信，那是你没看见我放弃那会儿。话说失恋确实可以让人减肥啊，还有可能是那几天太热没有什么食欲，体重自动掉了七斤，虽然身上还是有肥肉，但是感觉整个人都瘦了，脸上的骨头都清晰可见了，打起精神，今天是研究生正式入学的第二周，明天选课，然后每天就要去上课了，实验室的项目我都不知道从何下手，老师说了让我研究社会工程学，在网上根本找不到一些比较好的期刊和论文。 最近的规划 自己要有一个稍微明确一点的研究方向，能跟上现在实验室这个项目的脚步，我现在还找不到着手点，感觉无从下嘴。 选完课之后就去认真听讲，说真的，英语我要拿起来好好学，我想要学习一些英语，多练练口语，英语真的很关键，每天扩充一下词汇量。不想听的课就直接到实验室做自己想做的事。 实验室目前想做的事就是我自己的那个项目，这个算是一个比较次要的，练手的东西，争取在11月份结束吧。然后学一些自己想学的东西，想学的东西参照前一篇随笔。 稍微增加一下课外生活，等兼职的钱拿到手之后，办健身卡或者不办，哈哈哈，主要是看到时候能不能找到健友。周末打网球，丰富一下课余生活，不光是看剧之类的。 写在最后新学年有新气象，是这么说的吗，哈哈哈，博客也是自娱自乐的地方。嘿嘿，年轻人，加油啊，做爱记得戴套，珍爱生命，生活还很美好。","categories":[],"tags":[{"name":"随笔","slug":"Essay","permalink":"http://yoursite.com/tags/Essay/"}]},{"title":"个人项目服务器端之数据库部分","slug":"个人项目服务器端之数据库部分","date":"2017-08-07T02:57:17.000Z","updated":"2017-12-22T06:34:22.116Z","comments":true,"path":"2017/08/07/个人项目服务器端之数据库部分/","link":"","permalink":"http://yoursite.com/2017/08/07/个人项目服务器端之数据库部分/","excerpt":"","text":"写在前面这个项目目前的剩余任务是android客户端的编写和java端服务器基本功能的完善，聊天记录，断点续传文件之类的先要等我把聊天的基本功能实现之后，android都好久没写了，有点怕怕的。 正文这个项目的主要目的是为了用一下学到的java se的基础知识，所以会用到很多不同的东西来实现功能，也许这种实现方式并不是最优解。 只为了完成基础的功能模块，所以先定义了两个表，一个是user，另一个是friendgroup。 在服务器端维护了一个所有在线用户的列表，除此之外，数据库对于好友关系表的设计我在网上查了查，两种方案，一种是新建好友关系表，用户id和好友id对应（用户id小于好友id），强好友关系中减少冗余，另一种是用逗号分隔隔开所有的好友id，第二种设计起来比较简单，但是感觉有点蠢，第一种就是数据关系比较清晰，但是数据操作可能比较负责，所以好友关系选择了第一种，群组关系采用第二种。 在客户端和服务器的信息传送使用了udp协议，主要是为了后期群聊的实现可以使用MulticastSocket实现群发消息的功能。本来是想传送xml文件顺便用一下dom4j，但是感觉略蠢，后面可能会用java写爬虫，到时候再试也不迟，就还是用datagrampacket的构造参数byte[]发送消息，现阶段不考虑安全性，反正我也是玩玩，安全性后面再说，虽然这种不加密传输我自己也感觉不爽，哈哈哈 消息传输的协议百度了之后决定采用类似qq的操作，嘿嘿。 数据库中的一些问题 利用modify修改列的时候需要加上列的类型，即使列类型不变也需要加入。 不能插入中文需要modify要插入中文的列的字符集为gbk,具体操作是alter table table_name modify column_name column_type character set gbk; statement和preparedstatement的用法上有一些差异，statement的创建过程不需要SQL语句，而preparedstatement需要预编译带有占位符的sql语句，执行execute的时候就不需要参数了。 一些数值类型后面都有括号，并且其中还有数字，比如说int（10），int（4）等等，这些都是可选的参数，表示的是显示的宽度，并不能影响int类型的数值范围，比如说int就是4个字节，不会发生变化，但是在zerofill的情况下，int（4）是0001，把这个数字放到int（10）类型的列中，就会变成0000000001. 一些之前没注意过的地方 java中byte和int包括其他基本类型的转换中需要与上0xFF，这是需要保证补码的一致性，因为字节数比较小的类型向大的类型转换时会自动补位，正数补0，负数补1，所以需要与上0xff，才能保证补码的一致性。 java中DatagramSocket起到了一个快递接收点的作用，他只能发送包，但不知道包去哪里了，而快递DatagramPacket在构造的时候加入了目的地的地址和端口，DatagramSocket使用什么端口是无所谓的，只要在DatagramPacket中加入正确的端口。 一些小技巧 public static native void arraycopy(Object src,int srcPos,Object dest, int destPos,int length); src：源数组；srcPos：源数组要复制的起始位置；dest：目的数组；destPos：目的数组放置的起始位置；length：要复制的长度","categories":[],"tags":[{"name":"java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"数据库","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"算是个开始吧","slug":"20170802","date":"2017-08-03T03:17:30.000Z","updated":"2017-12-22T06:34:22.085Z","comments":true,"path":"2017/08/03/20170802/","link":"","permalink":"http://yoursite.com/2017/08/03/20170802/","excerpt":"","text":"进入了大学好几年，语文的作文功底真的都没有了，我都不敢说还给老师，估计我的功底老师都看不上了，写什么的时候也是想到哪里写到哪里，所以我准备记个从大学开始的流水账，反正随便写写，以后老了还能看，哈哈哈（滑稽脸）。 本科篇高考完之后就在家里待了两个月，基本上一个人没出过远门，虽然爷爷奶奶极力要求父母来送我，但是因为父母要上班也没人送我，我哥也开学了，一个人第一次坐火车，坐地铁，从西安来到了北京某211高校，报完名之后就被快拉到乡里了，哈哈，高中的时候虽然在学校也算是个学习不错的孩子，但是我知道天外有天，人外有人，所以我对自己在大学的学习成绩啥的也不在意，只要不挂科就可以了，事实证明我做到了，我也没准备在大学好好学习，哈哈哈哈，可能是高中被压迫太久了，军训的时候就给班里的一个妹子表白，那个妹子和我一样高，虽然身高不是最重要的原因，反正最后也失败了，而且关系尴尬了四年，大一第一学期就是很不习惯，那时候也没买电脑，玩玩手机，无聊了就去自习，成绩也还行，反正差不多能看得过去，每天其实挺无聊的，认识的人都是宿舍的，因为高中的时候不怎么和不熟的人交流导致比较害羞（现在认识我的人听了估计想打人），就每天吃的比较多，然后从不到100飙升到120，从矮子变成矮胖子了（真的心疼自己），那时候参加了学校的志愿者协会还有社团，慢慢的变得大方并且能说会道，不断bb，大二回到城里之后，就给一个妹子表白了，我从那时候就觉得自己在这方面的情商为0了，妹子也没拒绝我，但是也没正式答应我，感觉那意思就是让我追她，我这个人也是有点懒，但是妹子都这样了，说明有戏啊，然后妹子和闺蜜一起喝酒之后，我问要不要去接妹子，妹子的闺蜜接了电话怼了我之后，我就知道这事估计没戏了，因为我知道闺蜜要是这样子，结果也不会好，所以就自动放弃了（妹子估计觉得我是个傻子），强迫自己去想别的，和别人一起玩，娱乐生活还比较多了，搞搞老乡聚会啊之类的，周围的人也比较多了，用上了某著名yp软件，从此打开了新世界,算是变得越来越不要脸了，大二得了奖学金小小的挥霍了之后就觉得钱是个好东西，所以大三就去兼职，实习，基本上整个大三都在实习，但是没找什么正经公司，也算是个小遗憾吧，大三下思考完人生之后就决定考研了，主要还是觉得自己学的一般般，本科出去估计也找不到好工作，所以就下定决心考上了研究生。 研0篇刚进实验室的时候就想着要做安卓安全方面的工作，所以ycx师兄就建议我在github上搭个博客，把自己学习到的一些不错的东西写下来，一个是别人可以看，另一个是自己也可以时不时地复习，这个博客就搭了一两个月，刚开始撘不成功，在本地上可以看，但是不能上传到github，隔了一个月之后又想要自己做个项目，所以就想写点东西，所以又开始搭，这一次是在本地上不能打开，但是能上传到github，发现可以了，然后主题又换不了，自己折腾了好久最后一切都成功了，所以没什么搭建的教程，因为我tm也不明白到底怎么就成功了，哪天申请个域名这事就算完了，今天就想写点东西，还能练练markdown的常用语法,赶紧让我说说废话，不然我要憋死了，因为能聊的基友要不就回家了，要不就退学重新念高三了，感觉自己这个人有毒。 （睡了一晚上感觉bb的愿望不强了）从大四下进实验室到现在也有三个多月了，经历了很多，所以也有很多想说刚开始信誓旦旦地觉得自己本科是信息安全，研究生就想做网络安全相关的研究，研究生的专业也是网络空间安全，梦想着做个黑客，然而却没有想过，大学四年其实有无数的机会进入这个方向，但是自己都想过，也怯弱过，因为做一个黑客技术流，如果催动的兴趣不是很强，在这条路上可能很难长久地走下去，所以尽管研究生的时候想要去钻研安卓安全，但是自己好像对这方面真的不感兴趣，我个人探索的兴趣貌似不太强烈，所以到现在我就准备学好java，原本准备写一些关于安卓安全的博客，目前看来要变成java和android开发了，结果最后还是变成了程序猿，就是因为对自己定位不明确，一直在摇摆，所以wb老师才会让我去跟着wch老师做社会工程学的项目吧，其实我想把研究生当技校上，但很明显是不科学的，以后要读的论文还多着呢，本科的时候从来都觉得自己从某211高校毕业了就要去工作，总是觉得三年的工作经验要比三年的研究生生涯更有用，可是那时候的事情谁说的准呢，因为研究生，我还认识了自己喜欢的那个ta，虽然整个过程都tm很魔幻，但总归是遇见了，希望能长久吧，之前也算是被伤害过的男人吧，也不想谈恋爱，总觉得两个人在一起很麻烦，拒绝了那么几个人，那时候还不想做程序猿，可是现在想想自己好像也只能做程序员，吹逼的能力还不能达到产品经理，刚开始说要做安卓安全，看了看smali和dex之后，就觉得搞安全都没什么方向，我这个人比较讨厌这种没有目标的事，让我觉得自己是个无头苍蝇，所以就在安卓安全和安卓开发或者java后台中纠结，到现在算是下定决心了，以后不会再搞安全了，先踏踏实实的深入学习java开发吧。最近在做个完全是由于兴趣驱动的，其次是想要巩固一下之前的java se的一些开发知识，不能总是纸上谈兵，还有那些年开发过的渣渣安卓，感觉都很表层，准备拿出来深挖一下，目前这个暑假感觉也没什么活，就先做这个小项目吧，主要是安卓客户端和java服务器，一个类似于微信的东东，主要是自己想玩一下，自己做出来一个简易版微信还是很有成就感的，哈哈哈，最近可能会写这个吧，以后每周都准备写一篇，最少写一篇吧，这周的这篇就是这个了，哈哈，个人也是很懒的，虽然一直致力于成为一个勤快人，最近就先搞搞这个，然后再学习一下java的spring框架和java底层的东西吧，我现在都不知道spring是干嘛的，哈哈哈，就这样吧。","categories":[],"tags":[{"name":"随笔","slug":"Essay","permalink":"http://yoursite.com/tags/Essay/"}]}]}