<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-markdown语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/22/markdown语法/" class="article-date">
  <time datetime="2018-03-22T08:18:03.915Z" itemprop="datePublished">2018-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/22/markdown语法/">markdown语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="标题是这样的"><a href="#标题是这样的" class="headerlink" title="标题是这样的"></a>标题是这样的</h2><h1 id="还可以是这样"><a href="#还可以是这样" class="headerlink" title="还可以是这样"></a>还可以是这样</h1><p>标题后面加任意数量的“-”或者“=”，两种表示方式后面的-和=是随意的，1到无穷大，但后面的数量和标题的级别没关系。</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>一定数量的#加标题，以此类推，无穷矣。</p>
<blockquote>
<p>区块引用，目前还没看出来这种引用有什么用途，唯一需要做的就是在某段文字的最前面加上&gt;,或者在这段文字的每一行前面加上&gt;.<br>引用中层次的不同只需要改变前面的&gt;的数量</p>
<blockquote>
<p>二级引用，引用中的引用，你值得拥有。（改这一行前面的&gt;的数量）</p>
<blockquote>
<p>就是这么神奇。。。。。</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>无序列表的使用就是在每一项的前面加上一个*、+、-</li>
</ul>
<ul>
<li>效果都是一样的，而且可以混用</li>
</ul>
<ul>
<li>但是一般情况还是统一用一种，看起来比较整齐。</li>
</ul>
<p>￥￥￥￥￥￥</p>
<ol>
<li>有序列表就很简单了，但也很扎心</li>
<li>直接在某项前面加上数字和点</li>
<li><p>扎心的地方在于如果直接跟在无序列表后面的话，有序的这部分就会直接无序，所以我用了六个人民币符号隔开了。</p>
<p> 代码区块就是行首缩进一个制表符，Class.forName(“xxxx”);<br> 就是这样 </p>
</li>
</ol>
<hr>
<p>上面的就是分隔线，三个以上的“<em>”和“-”“就可以出现这种效果 ，这几个“-”和“ \</em> ”可以用空格隔开，也可以不需要</p>
<hr>
<h2 id="超链接的用法"><a href="#超链接的用法" class="headerlink" title="超链接的用法"></a>超链接的用法</h2><p>这是一个超链接的<a href="http:www.baidu.com/&quot;title&quot;" target="_blank" rel="noopener">示意</a>,主要的用法就是把需要超链接的部分用方括号[]括起来，后面紧跟圆括号，圆括号里面是超链接的地址</p>
<hr>
<p>[baidu][hhh]第二种用法是这样的，方括号括起来的文字后面紧跟方括号括起来的id，随便id是什么，然后在文章的任意一个部分加上[id]:具体链接，这样就可以了，<br>[hhh]: http:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p><strong>一句话前后各两个“*“号的作用是粗体</strong>，<em>一个“\</em>”的作用是斜体*</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/22/markdown语法/" data-id="cjf28yp8n0015w8hu2hupq3au" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-20171110" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/22/20171110/" class="article-date">
  <time datetime="2018-03-22T08:18:03.719Z" itemprop="datePublished">2018-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/22/20171110/">20171110</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>普通索引、唯一索引（索引值唯一，unique关键字）、全文索引（fulltext关键字可以设置，只能创建在char，varchar，text类型的字段上）、单列索引、多列索引、空间索引（只有 MyISAM支持，只能建立在空间数据类型上）。</p>
<pre><code>create table 表名(
属性名 数据类型[约束条件]，
…………
[UNIQUE|FULLTEXT|SPATIAL] INDEX KEY
[别名] (属性名[(长度)] [ASC|DESC])
);
</code></pre><p>举个栗子</p>
<pre><code>create table student（
id int not null primary key auto_increment,
abd varchar(50),
index hahaha(id)）;
</code></pre><p>索引名是hahaha，索引的内容是id列，哈哈哈是别名，如果不指定别名将直接使用列名作为索引名</p>
<hr>
<p>在已有表上新建索引</p>
<pre><code>CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX index_name 
ON table_name(属性 [(length)] [ASC | DESC]);
</code></pre><p>修改表结构添加索引</p>
<pre><code>alter table 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX index_name (属性 [(length)] [ASC | DESC]);
</code></pre><p>注意上面两种的区别，主要需要注意的地方是前者是表名+列名“table_name(属性 [(length)] [ASC | DESC])”，后者是索引名+列名“INDEX index_name (属性 [(length)] [ASC | DESC])”。<br>用show create table 表名可以查看该表的定义</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><pre><code>delimiter //
create procedure 存储过程名（参数的输入输出类型 参数名 参数类型，………）
begin 
SQL语句
end//
</code></pre><p><strong>sql语句中用“；”作为结束标志，所以在定义存储过程之前应该将语句结束标志换成其他字符，更改结束标志可以用关键字“delimiter”。  </strong></p>
<h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><pre><code>delimiter //
create function 存储函数名（参数名 参数类型，………）
returns 返回值类型 
begin 
SQL语句
end//
</code></pre><p><strong>这个地方需要注意的是返回值类型前面的是returns</strong></p>
<h2 id="局部变量声明"><a href="#局部变量声明" class="headerlink" title="局部变量声明"></a>局部变量声明</h2><p>declare 变量名 变量类型；<br>局部变量只在某个begin······end块内有效</p>
<h2 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h2><p>会话变量不必声明，可以直接使用，会话变量名以“@”为起始字符。</p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><ol>
<li>declare 变量名 变量类型 default 默认值；</li>
<li>set 变量名=值；</li>
<li>select 字段1名  INTO 变量名 FROM 表名 where condition 。。。。将表中满足condition的部分的字段1的内容赋值给变量。这种方式只能在begin和end之间使用。</li>
</ol>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>有时候查询语句的结果是多条语句，使用游标必须先声明</p>
<pre><code>declare 游标名 cursor for SELECT_STATEMENT
</code></pre><p>使用游标之前必须“open 游标名”，游标在顺利打开之后可以使用FETCH·····INTO语句来读取数据。</p>
<pre><code>FETCH 游标名 INTO 变量名········
</code></pre><p>变量名必须提前定义好，使用完毕之后要关闭游标 “close 游标名”</p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><pre><code>IF condition THEN
ELSE condition THEN
······
ELSE
······
ENDIF;
</code></pre><p>CASE语句</p>
<pre><code>case 变量名
    when value THEN······
    when value THEN······
    else （和switch里面的default类似，默认语句）
end case;
</code></pre><h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><pre><code>while condition do
·······
end while; 
</code></pre><h3 id="loop循环语句"><a href="#loop循环语句" class="headerlink" title="loop循环语句"></a>loop循环语句</h3><pre><code>loop循环名:loop
·······
满足条件  leave loop循环名;
end loop;
</code></pre><h3 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h3><pre><code>repeat 
······
until condition
end repeat
</code></pre><p>前面的三种循环中可以使用“iterate label”，和java中的continue关键字同样的作用，直接开始下一次循环</p>
<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><p>”call 存储过程名（存储过程的参数）;“，在命令行下，这里的参数如果是输入参数就直接输入值，如果是输出参数则使用全局变量，再通过select 输出变量值。</p>
<h2 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h2><p>存储函数和MySQL内部函数的使用方法基本相同，“select 存储函数名（存储函数参数）;”</p>
<h2 id="查看存储过程和函数"><a href="#查看存储过程和函数" class="headerlink" title="查看存储过程和函数"></a>查看存储过程和函数</h2><pre><code>show { procedure | function } status [like &apos;pattern&apos;]
和
show create{ procedure | function } 存储过程和函数的名字
</code></pre><p>第一种只能用like关键字匹配存储过程和函数名称。如果要查看详细定义，需要使用show create语句。</p>
<p>目前MySQL还不提供对已存在的存储过程和函数的代码进行修改，如果一定要修改只能删除后重新定义。现在只能修改对于存储过程和函数的权限和解释。</p>
<pre><code>ALTER {PROCEDURE | FUNCTION} sp_name [characteristic……]
</code></pre><p>参数说明<br>Sp_name，表示存储过程或函数的名称<br>characteristic，表示要修改存储过程的哪个部分<br>Characteristic的取值如下 </p>
<p>CONTAINS SQL，表示子程序包含SQL语句，但是，不包含读或写数据的语句<br>NO SQL，表示子程序中，不包含SQL语句<br>READS SQL DATA，表示子程序中，包含读数据的语句<br>MODIFIES DATA，表示子程序中，包含写数据的语句<br>SQL SECURITY {DEFINER | INVOKER}，指明谁有权限来执行<br>DEFINER，表示只有定义者，自己才能够执行<br>INVOKER，表示调用者可以执行<br>COMMENT’string’，表示注释信息  </p>
<h2 id="捕获存储过程中的错误"><a href="#捕获存储过程中的错误" class="headerlink" title="捕获存储过程中的错误"></a>捕获存储过程中的错误</h2><p>预测程序在执行过程中可能出现或遇到的问题<br>先用declare语句定义条件，语法格式如下</p>
<pre><code>declare 条件名称 CONDITION FOR condition_value
</code></pre><p>condition_value：SQLSTATE sqlstate_value | mysql_error_code，其实这里类似于给condition_value起了个别名,其实并不是很需要这一步。</p>
<p>定义处理程序</p>
<pre><code>declare handler_type handler for condition_value[,...] sp_statement  
</code></pre><p>其中, handler_type的取值范围：continue | exit<br>这个语句指定每个可以处理一个或多个条件的处理程序。如果产生一个或多个条件，指定的语句被执行。 对一个continue处理程序，当前子程序的执行在执行处理程序语句之后继续。对于exit处理程序，当前begin…end复合语句的执行被终止。</p>
<p>condition_value的取值范围：sqlstate [value] sqlstate_value | condition_name | sqlwarning | not found | sqlexception | mysql_error_code  </p>
<p>SQLWARNING是对所有以01开头的SQLSTATE代码的速记。<br>NOT FOUND是对所有以02开头的SQLSTATE代码的速记。<br>SQLEXCEPTION是对所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的速记。</p>
<p>sp_statement  是错误处理代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/22/20171110/" data-id="cjf28yp86000gw8hupjqdy7tg" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20180319 struts" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/19/20180319 struts/" class="article-date">
  <time datetime="2018-03-19T00:37:12.000Z" itemprop="datePublished">2018-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/19/20180319 struts/">20180319</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个表单里包含多个提交按钮，分别提交给不同的控制逻辑，和上周方法不同的方法是，将一个Action处理类定义成多个逻辑Action，在struts.xml中配置action的时候可以指定method属性来让action调用特定的方法处理，而不是默认使用execute方法，这些方法必须具有相似的方法签名，形参列表为空，方法返回值为String。</p>
<p>在struts.xml中配置action允许在<strong>指定name属性</strong>时使用模式字符串（用*代表一个或者多个任意字符），接下来就可以在class、method和result元素中使用{N}的形式代表前面第N个星号（*）所匹配的子串</p>
<pre><code>&lt;action name=&quot;*Action&quot; class=&quot;cc.LoginRegistAction&quot; method=&quot;{1}&quot;
</code></pre><p>上面的这段代码其实就是根据传入的action名称选择method，也可以在类名里面使用{N}，没有为Action指定class属性，该action使用ActionSupport作为处理类，而且因为该ActionSupport类的execute方法默认返回success字符串</p>
<p>如果有URL为abcAction.action的请求，如果struts.xml文件中有名为abcAction的action，则一定由该action处理用户请求，如果struts.xml文件中没有名为abcAction的action，则搜寻第一个个能够匹配abcAction的Action，例如*Action和*，*Action并不会比*匹配的优先级高，先找到那个Action就由哪个Action处理请求。所以说name=“*”的Action一般配置在最后。</p>
<p>配置默认Action通过&lt;default-action-ref…../&gt; ，struts.xml文件中使用&lt;result…./&gt;元素配置结果，根据&lt;result…/&gt;元素所在位置的不同，struts2提供了两种结果，局部结果（result作为action的子元素）和全局结果（result作为global-results的子元素），配置result元素的时候通常要指定两个属性name和type，Struts2默认的结果类型就是dispatcher，所以在配置result的时候可以省略type元素，默认name是success，没有指定location参数，会把&lt;result….&gt;………中间的字符串当成实际视图资源。</p>
<p>如果result的type是plainText的话将会返回网页源代码，指定location和charSet（处理字符集）；result的结果如果是redirect；类型，将产生新的请求，所有的请求参数、请求属性、Action实例和Action中封装的属性全部丢失。使用redirect类型的结果时，不能重定向到/WEB-INF/路径下任何资源，因为<strong>web应用的/WEB-INF/路径下的所有资源是受保护对象</strong>；redirectAction结果类型和redirect都是重新生成全新的请求，配置redirectAction的时候需要指定两个参数actionName和namespace。</p>
<p>配置result元素的时候，不仅可以使用${0}表达式形式来指定视图资源，还可以使用${属性名}的方法指定，属性名就是对应的Action实例里的属性，<strong>OGNL表达式就是${属性名.属性名.属性名…….}</strong>，如果result放在global-results元素中配置的话，该result元素就是全局结果，对所有的Action都有效，但是局部结果会覆盖全局结果。</p>
<p>PreResultListener是一个监听器接口，他在Action完成控制处理之后，系统转入实际的物理视图之间被回调，可以为Action和拦截器添加这个监听器，监听器中一个方法叫做beforeResult。</p>
<h3 id="struts2-异常处理"><a href="#struts2-异常处理" class="headerlink" title="struts2 异常处理"></a>struts2 异常处理</h3><p>在execute中处理异常的比较麻烦的，最好的处理异常的方法是通过声明式的方式管理异常处理。因为如果写在代码里异常发生变化需要重新修改代码。struts2的异常处理机制需要一个拦截器，但是默认已经开启。</p>
<p>异常处理实在struts.xml中配置exception-mapping元素完成的，配置该元素的时候需要制定两个属性，一个是exception，一个是result，根据exception-mapping出现的位置可以分为全局异常映射和局部异常映射，同样，局部异常映射会覆盖全局异常映射。</p>
<p>在struts2中可以通过如下标签输出异常信息</p>
<pre><code>&lt;s:property value=&quot;exception&quot;/&gt;：输出异常对象信息
&lt;s:property value=&quot;exceptionStack&quot;/&gt;：输出异常堆栈信息   
</code></pre><h3 id="Convention插件与“约定”支持"><a href="#Convention插件与“约定”支持" class="headerlink" title="Convention插件与“约定”支持"></a>Convention插件与“约定”支持</h3><p>约定优于配置，只需要按照约定开发，不需要进行配置，只需要把convention的jar包导入到lib中。</p>
<p>Convention插件会把所有实现了com.opensymphony.xowrk2.Action的java类和所有类名以Action结尾的Java类作为Action处理。默认值只会处理action、actions、struts、struts2包下的java类，这个插件还可以设置不扫描哪些包下的java类，以及新增需要扫描的包，以及设置包搜索开始的根包。根命名空间就是上面说过的默认的扫描文件，下面的子包则被映射成对应的命名空间。</p>
<p>Action的name属性根据Action类的类名映射，如果该Action类名中包含Action后缀，就将Action去掉，将剩余的驼峰写法（每个单词首字母大写）转成中划线写法（所有字母小写，单词与单词之间以中划线隔开），在使用这个action的时候应该是<strong>命名空间/Action名称</strong></p>
<p>按照约定映射Result，默认情况下，Convention总会到Web应用的WEB-INF/content，定位资源的约定是ActionName+resultCode+suffix（后缀），找不到对应资源的时候会使用actionname+suffix作为资源，action的url中是带着命名空间的，那么在content中也需要带上命名空间。</p>
<p>如果希望一个Action结束处理后进入另一个Action形成Action链，那么就不能包含第一个Action逻辑视图字符串对应的视图资源，而且第一个Action和第二个Action处于同一个包之下，第二个Action映射的URL为第一个action的名称和resultcode，例如名为FirstAction的Action返回了值为second的resultcode，那么第二个Action的类名是FirstSecondAction</p>
<p>Convention插件支持自动重加载机制，需要设置struts.devMode为true，以及struts.convention.classes.reload为true</p>
<h3 id="使用Struts2的标签库"><a href="#使用Struts2的标签库" class="headerlink" title="使用Struts2的标签库"></a>使用Struts2的标签库</h3><p>标签库的标签不依赖于任何表现层技术，struts2的标签都定义在URI为“/struts-tags”的空间下</p>
<p>Ajax（Asynchronous JavaScript And XML）</p>
<h4 id="OGNL（struts2标签库的语法）"><a href="#OGNL（struts2标签库的语法）" class="headerlink" title="OGNL（struts2标签库的语法）"></a>OGNL（struts2标签库的语法）</h4><p>Struts2可以直接从对象中获取属性，会自动搜寻Stack Context的所有实体，从栈顶到栈底 ，知道找到与求值表达式匹配的属性，Stack Context的根对象是ValueStack，除此之外还包括了命名对象，struts2还提供了命名对象，访问这些对象需要使用#前缀来指明，parameters对象（访问http请求参数）、request对象、session对象、application对象、attr对象（该对象将依次搜索如下对象：PageContext、HttpServletRequest、HttpSession、ServletContext中的属性）</p>
<p>可以在任意页面增加&lt;s:debug/&gt;标签，该标签将生成一个链接，可以进行调试。</p>
<p>直接创建List类型集合的语法：{e1,e2,e3………}；直接生成Map类型集合的语法是#{key1:value1,key2:value2,…………}；in和not in可以用来判断某个元素是不是在指定集合中。</p>
<p>OGNL还允许通过某个规则取得集合的子集，？（取出所有符合选择逻辑的元素）、^（取出符合选择逻辑的第一个元素）、$(取出符合所有选择逻辑的最后一个元素)。preson.relatives.{? #this.gender==’male’}直接在集合后紧跟.{}运算符勇于取出该集合的子集，#this代表集合里的元素。</p>
<p>struts2提供了访问静态成员的方法，但默认是关闭的，需要设置struts.ognl.allowStaticMethodAccess设置为true。可以通过@className@staticField和@className@staitcMethod（val） </p>
<p>OGNL支持基本的Lambda表达式语法，可以使用函数</p>
<p>&lt;s:iterator…./&gt;标签有三个属性：value指定被迭代的集合。id是集合里元素的id（迭代变量）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/19/20180319 struts/" data-id="cjf28yp8j0010w8huxd37qgf4" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Struts/">Struts</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20180313 struts" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/13/20180313 struts/" class="article-date">
  <time datetime="2018-03-13T00:55:12.000Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/13/20180313 struts/">20180313</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>eclipse生成部署Web项目的时候，会自动将src路径下除了*.java外的所有文件都复制到web应用的WEB-INF\classes路径下。</p>
<p><strong>在WebContent下面的文件在配置中就是从根目录开始的，如果是WebContent下面的子文件夹，比如是WEB-INF中的content文件下的mo.jsp文件需要设置为/WEB-INF/content/mo.jsp</strong></p>
<p>Struts2推荐把所有视图页面存放在WEB-INF目录下，避免直接向视图界面发送请求，struts.xml中配置了一个name=“*”的&lt;action……/&gt;，这个元素可以处理所有的请求，直接呈现WEB-INF/content目录下同名的jsp页面。</p>
<h2 id="Struts2应用的开发步骤"><a href="#Struts2应用的开发步骤" class="headerlink" title="Struts2应用的开发步骤"></a>Struts2应用的开发步骤</h2><ol>
<li>在web.xml中定义filter拦截用户请求</li>
<li>如果以post方式提交请求，则需要定义包含表单数据的jsp页面，如果仅仅是get方式，则无需经过这一步。</li>
<li>定义处理用户请求的Action类（Actionsupport）。Action是MVC里的C</li>
<li>配置Action。指定哪个请求对应于哪个Action进行处理。Convention插件支持“约定优于配置”的思想，采用约定的方式来规定请求和action之间的对应关系。</li>
<li>通常action处理用户请求之后会返回一个字符串，在struts.xml中可以配置这个字符串和物理视图（要返回给用户的界面）之间的对应关系</li>
<li>如果action需要发送数据给试图自愿，可以借助DGNL表达式。</li>
</ol>
<p>Struts.xml通常放在web应用的类加载路径下，通常是放在WEB-INF/classes路径下，主要作用就是配置action和请求之间的对应关系，还可以使用struts.properties文件来管理常量，标准properties文件，key-value对。这些常量会对整个struts2应用起作用，同样放在WEB-INF/classes下。</p>
<p>struts2会自动加载struts.xml（开发者自定义配置文件）、struts-default.xml（struts2自带配置文件）、struts-plugin.xml（struts2插件的配置文件）</p>
<p>Struts2配置常量有三种方式：struts.properties\struts.xml\web.xml，在struts.xml中可以通过constant元素配置，在web.xml中配置StrutsPrepareAndExecute时也可以配置struts2常量，通过为filter配置初始参数的方法配置struts2常量</p>
<p>struts2框架加载常量的顺序是struts-default.xml、struts-plugin.xml、struts.xml、struts.properties、web.xml，后面的重名常量会覆盖之前的常量。</p>
<p>为了避免struts.xml文件过于庞大，所以可以通过include元素手动导入配置文件</p>
<pre><code>&lt;s:textfield name=&quot;Xxx&quot; key=&quot;&quot;&gt;
name是action定义类中的常量名称，key是显示在页面上的文字
</code></pre><p>Action中的实例变量不仅可以封装请求参数，也可以用来封装处理结果</p>
<p>Action接口规范中统一定义了5个字符串常量：ERROR、NONE、INPUT、LOGIN、SUCCESS，实现类ActionSupport</p>
<p>Web应用中经常要用到HttpServletRequest、HttpSession、ServletContext，这三个分别是jsp内置对象中的request、session和application，Struts2提供了ActionContext</p>
<p>Action直接访问Servlet API，实现三个接口就可以实现，ServletContextAware、ServletRequestAware、ServletResponseAware</p>
<p>ServletContext是在服务器上共享的一片区域，而session则是每一个用户自有的一块区域。</p>
<p>Struts2中的Action在一个包中，包用package配置，每个包里面有很多个Action和拦截器，package的name属性是引用该包的唯一标识。extend属性可以用来继承另一个包，还有抽象包的概念，抽象包不能有Action的定义。</p>
<p>interceptors是拦截器，下面的这段代码的action的name是*，代表请求的网页是和action同名的jsp</p>
<pre><code>&lt;action name=&quot;*&quot;&gt;
    &lt;result&gt;/WEB-INF/content/{1}.jsp&lt;/result&gt;
</code></pre><p>每次定义一个package元素的时候，都可以指定一个namespace属性，因为同一个web应用可能会包含同名Action，如果配置package的时候没有指定namespace，当某个包指定了命名空间，该包下所有的action处理的URL应该是命名空间+Action名，当系统收到请求时，会现在命名空间里查找，如果没有的话会去默认空间查找。</p>
<p>同一个页面里的不同按钮想要交给不同的控制逻辑，也就是说一个jsp页面中的提交想要分别提交给action的不同方法处理，action=“actionName！MethodName”，通过一个jsp的函数在点击按钮之后利用onclick动态的改变了表单的action，这种方法就是动态调用，动态调用的方法除了函数名和execute方法不同之外，其他的都必须一样。使用动态调用必须要设置struts2允许动态调用，设置struts.enable.DynamicMethodInvocation常量为true。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/13/20180313 struts/" data-id="cjf28yp8o0018w8hujd85fe9r" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Struts/">Struts</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/18/JavaEE/" class="article-date">
  <time datetime="2018-01-18T08:10:39.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/18/JavaEE/">JavaEE</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java EE应用的分层模型大致有如下几层：</p>
<ol>
<li>Domain Object(领域对象层)：一些简单的java类，类内部包含了业务的实现逻辑。</li>
<li>DAO（Data Access Object）：对数据库的操作。</li>
<li>业务逻辑层：这些业务逻辑方法可能仅仅用于暴露Domain Object对象所实现的业务逻辑方法或者DAO组件的业务逻辑方法。</li>
<li>控制器层：拦截用户请求，调用业务逻辑组件的方法。</li>
<li>表现层：一系列页面组成，负责收集请求，并显示处理结果。最常见的技术是JSP（Velocity、FreeMarker和Tapestry）</li>
</ol>
<p><strong>保证业务逻辑方法的实现，与具体的持久层访问技术分离</strong>，持久层我的理解就是数据和物理设备之间的操作。</p>
<p>JSP不能直接访问应用的底层状态，Java EE会使用选择JavaBean来传输数据，</p>
<p>Struts是MVC框架，同时替代技术有Spring MVC和JSF</p>
<p>JavaEE应用需要一种能够让Java以面对对象的方式操作关系数据库的技术，ORM（Object Relation Mapping），Hibernate框架是一种开源的、轻量级的ORM框架，他允许将普通的、传统的Java对象（POJO）映射成持久化类，允许应用程序以面向对象的方式才操作POJO，而Hibernate框架负责将这种操作转换成底层的SQL操作。Mybatis允许将SQL语句查询结果映射成对象，是Hibernate的替代技术。</p>
<p>Spring框架里包含各种设计模式的应用，中间层容器，向上与MVC框架无缝融合，向下可以与各种持久层框架无缝整合。没有替代技术。</p>
<p>在Tomcat中部署Web应用的方式有四种：</p>
<ol>
<li>利用Tomcat的自动部署。</li>
<li>利用控制台</li>
<li>增加自定义的web部署文件</li>
<li>修改server.xml文件部署web应用</li>
</ol>
<p>Ant是java世界的Make，利用build.xml完成整个项目的编译，Ant工具会根据build文件中的配置进行整个项目的编译，project文件夹下包含了src（源文件、各种配置文件）、classes（编译后的class文件）、lib（第三方jar）、dist（项目打包和项目发布文件的文件夹）、build.xml（Ant生成文件）</p>
<p>build文件中的根元素是project，每个项目下可以定义多个生成目标，每个生成目标用target标签来定义，target的属性有name（运行target的时候就是根据name属性确定目标）、depends（运行该target之前必须运行depends指定的target）、if（if属性指定一个属性，只有这个属性被设置了才会执行target）、unless（这个属性没被设置才会执行这个target）、description</p>
<p>build文件中的property元素用来定义一个或者多个元素，该元素有name和value属性，而且该属性值不可改变，需要获取属性值，${property的name属性}，属性值的来源可以是属性文件的文件名、属性文件的资源名称、属性文件的url地址、系统环境变量、或者是属性文件的classpath。</p>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>maven常用的命令就是mvn。mvn的主要格式是mvn <plugin-prefix>:<goal> -D &lt;属性名&gt;=&lt;属性值&gt; ········<br>plugin-prefix是插件前缀，goal就是指定目标，-D就是用来指定属性名和属性值</goal></plugin-prefix></p>
<p>使用<a href="http://maven.apache.org/plugins/index.html可以查看Maven插件的功能和用法，创建项目使用Maven的archetype插件" target="_blank" rel="noopener">http://maven.apache.org/plugins/index.html可以查看Maven插件的功能和用法，创建项目使用Maven的archetype插件</a></p>
<p>用maven生成的项目中包含一个pom（project object model ）文件。该文件仅仅包含了一些项目的版本、groupID、artifactid等坐标信息</p>
<pre><code>mvn archetype:generate -DinteractiveMode=false -DgroupId=org.fkjava -DartifactId=mavenQs -Dpackage=org.fkjava.mavenqs

mvn compile

mvn exec:java -Dexec.mainClass=&quot;org.fkjava.mavenqs.App&quot;
</code></pre><p>即便该项目的POM文件中没有说明maven编译项目的具体过程，是因为当前项目的pom文件会被合并到上级pom文件中，上级的pom文件中定义了项目的大量默认设置。</p>
<p>Maven的插件可以指定多个可执行的目标，对于软件构建过程，默认的生命周期是compile、test、package、install、deploy。POM为项目提供一个唯一标识符，这个就是Maven坐标，由groupID（该项目开发者的域名）、artifactid（项目名）、packaging（打包类型）、version（项目版本），Maven坐标可以精确定位一个项目。</p>
<h1 id="Servlet-jsp回顾"><a href="#Servlet-jsp回顾" class="headerlink" title="Servlet/jsp回顾"></a>Servlet/jsp回顾</h1><p>web目录中的classes和lib文件夹都是用来保存web应用所需要的Java类文件，classes保存单个的class文件，而lib保存打包以后的jar文件</p>
<ol>
<li>java脚本 &lt;%  %&gt;</li>
<li>jsp注释 &lt;%–    –%&gt;</li>
<li>jsp声明 &lt;%!   %&gt;</li>
<li>输出jsp表达式 &lt;%=表达式 %&gt;输出表达式语法后不能有分号</li>
</ol>
<p>JSP的3个编译指令&lt;% 编译指令名 属性名=“属性值”  %&gt; page\include\taglib</p>
<p>jsp动作指令主要有如下7个：</p>
<ol>
<li>jsp:forward:页面转向</li>
<li>jsp:param：传递参数（forward和include需要使用该指令）</li>
<li>jsp:plugin：下载JavaBean或者applet到客户端执行</li>
<li>jsp:useBean：创建javaBean</li>
<li>jsp:setProperty：设置JavaBean的属性值</li>
<li>jsp:getProperty：输出JavaBean的属性值</li>
<li>jsp:include: 动态引入jsp页面（被导入页面的body内容插入本页面）</li>
</ol>
<p>通常不使用response直接响应，都是使用out对象，response常用于重定向，以及输出非字符对象。</p>
<p>jsp和servlet之间的数据交换是通过四个map结构，application、session（会话）、request（请求）、page。请求就是一次点击，会话就是浏览器的一个标签页，application就是整个服务器上所有的jsp和servlet都可以交换信息。</p>
<p>如果希望jsp页面可以获取web.xml配置文件中的配置信息，则必须通过为该jsp配置的路径访问该页面</p>
<p>jsp中的9个内置对象：</p>
<ol>
<li>application</li>
<li>config</li>
<li>exception：只有在errorpage中才可以用</li>
<li>out</li>
<li>pageContext：可以访问page、request、session、application范围的变量，pageContext还可以用来获取其他内置对象。</li>
<li>request</li>
<li>response</li>
<li>session</li>
</ol>
<p>GET方式发送的请求参数被附加到地址栏的URL之后，url?param1=value1&amp;param2=value2&amp;········paramN=valueN</p>
<p>post请求中的非西欧字符可以通过设置request的编码字符集，但是get请求中的非西欧字符（包括中文字符）只能通过java.net.URLDecoder类</p>
<p>使用request的getRequestDispatcher（String path）方法的时候，该path字符串必须以斜线开头。</p>
<p>response的重定向会丢失所有的请求参数和request范围的属性，二forward将会保留所有的请求参数。</p>
<p>一次用户会话的含义是：客户端浏览器链接服务器开始，到客户端浏览器与服务器断开为止，这个过程就是一次会话</p>
<p>HttpServlet包含init方法和destroy方法，这两个方法无须重写，除非在初始化servlet时，完成某些资源初始化的方法，才考虑重写init方法，销毁servlet之前先完成对于某些资源的回收才需要重写destroy。</p>
<p>为了让servlet响应用户请求，必须将servlet配置在web应用中，配置servlet有两种方式：1. 在servlet类中使用@WebServlet注解进行配置2.通过在web.xml文件中配置。</p>
<p>metadata-complete=”true”，会在启动时不扫描注解（annotation）。如果不扫描注解的话，用注解进行的配置就无法生效</p>
<p>有一种servlet在应用启动的时候就创建，用于某些后台服务的servlet或者是拦截请求的servlet。load-on-startup Servlet，配置的方式有两种：@WebServlet注解的loadOnStartup属性指定。或者是在web.xml中利用load-on-startup子元素进行配置，有一个整数值表示优先级，越小就越先实例化。</p>
<p>在web.xml中写明的Servlet参数可以通过ServletConfig对象完成。ServletContext获得的是整个Web应用的配置参数。</p>
<p>tld文件应该在WEB-INF的任意子路径下（tld文件是对自定义标签库的定义文件），tld文件中的uri是非常关键的，在使用自定义标签的时候需要明确uri才能找到指定的标签库</p>
<p>getJspBody()可以获得自定义jsp标签里的标签体</p>
<p>以“页面片段”为属性的标签需要在标签处理类中定义类型为JSPFragment的属性，这个属性代表“页面片段”，使用标签库的时候，通过<a href="jsp:attribute.../" target="_blank" rel="noopener">jsp:attribute.../</a>动作指令为标签的属性指定值。</p>
<p>需要传入自定义标签的属性个数是不确定的，需要动态属性的标签，标签处理类需要实现DynamicAttributes接口，配置标签时通过<dynamic-attributes>子元素指定该标签支持动态属性。</dynamic-attributes></p>
<p>Filter的种类：（filter的用法）</p>
<ol>
<li>用户授权的filter：检查用户请求</li>
<li>日志filter：详细记录某些特殊的用户请求</li>
<li>负责解码的filter：对非标准编码的请求编码</li>
<li>能改变xml内容的XSLT Filter</li>
</ol>
<p>ServletContextListener、ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、HttpSessionListener、HttpSessionAttributeListener</p>
<p>Servlet底层的IO是通过ServletInputStream和ServletOutputStream支持的，ServletInputStream新增了setReadListener方法，允许非阻塞IO读取数据，输出流也有同样的方法。使用的方法是：</p>
<ol>
<li>调用ServletRequest的startAsync（）方法开启异步模式</li>
<li>通过ServletRequest获取ServletInputStream，并为ServletInputStream设置监听器，实现ReadListener接口来实现监听器。</li>
</ol>
<h3 id="Tomcat-8-的WebSocket支持"><a href="#Tomcat-8-的WebSocket支持" class="headerlink" title="Tomcat 8 的WebSocket支持"></a>Tomcat 8 的WebSocket支持</h3><p>使用注解方式开发，被@ServerEndpoint修饰的java类饥渴作为WebSocket服务器，这个类中有四个需要定义的方法</p>
<p>Tag File支持：通过建立Tag文件，利用Tag File代替了标签处理类，Tagfile有5个编译指令，分别是taglib、include、tag、attribute（类似于自定义标签处理类的属性）、variable，在使用自定义标签的时候需要先导入标签库，再使用标签，<strong>和tld文件的不同在于这里是prefix和tagdir</strong>，tagdir标签库路径下存放着很多Tag File。每个Tag File对应着一个标签。</p>
<h3 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h3><ol>
<li><p>异步处理是通过AsyncContext类来处理的，AsyncContext类的dispatch方法把请求dispatch到指定JSP页面，被异步请求dispatch的目标界面需要在指定session=false，这样新的页面才不会重新创建session，<strong>异步调用需要配置</strong>，异步调用有自己的监听器，监听器需要实现AsyncListener接口  ，这里的监听器不像是servlet那种只要配置了就会自动运行的监听器，这个异步监听器必须注册在某个异步调用上。</p>
</li>
<li><p>HttpServletRequest增加了对文件上传的支持</p>
</li>
<li>ServletContext可以通过编程的方式动态注册servlet和filter</li>
</ol>
<p>HttpServletRequest提供了获得part的方法，每个part对应一个文件，part也有write的方法可以将上传文件写入到服务器的磁盘里。在页面中就需要设置input type=file，并且需要将表单域的enctype属性设置为multipart/form-data。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/18/JavaEE/" data-id="cjf28yp8l0013w8huwuwqmph6" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-20180116" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/20180116/" class="article-date">
  <time datetime="2018-01-11T08:40:38.000Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/11/20180116/">20180116</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Web容器安全管理"><a href="#Web容器安全管理" class="headerlink" title="Web容器安全管理"></a>Web容器安全管理</h1><pre><code>&lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;&lt;!--定义验证方式,basic是基本验证方式--&gt;
&lt;/login-config&gt;
&lt;security-role&gt;
    &lt;role-name&gt;admin&lt;/role-name&gt;
&lt;/security-role&gt;
&lt;security-role&gt;
    &lt;role-name&gt;manager&lt;/role-name&gt;
&lt;/security-role&gt;
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;Admin&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;
        &lt;http-method&gt;GET&lt;/http-method&gt;&lt;!--可以添加多个，只能分开写,默认设置代表所有的http方法都会受到限制--&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;
</code></pre><p>BASIC的验证方式只能通过对话框输入名称和密码，使用基本验证时无法自定义登录页面，如果需要自定义登录界面和登陆错误的页面，则可以改用容器所提供窗体验证。</p>
<pre><code>&lt;login-config&gt;
        &lt;auth-method&gt;FORM&lt;/auth-method&gt;
        &lt;form-login-config&gt;
            &lt;form-error-page&gt;登录错误页面&lt;/form-error-page&gt;
            &lt;form-login-page&gt;登录页面（路径必须从应用程序的根目录开始）&lt;/form-login-page&gt;
        &lt;/form-login-config&gt;
&lt;/login-config&gt;
</code></pre><p>这种FORM的方式在容器验证成功之后会在HttpSession中设置登录字符，所以可以通过检查字段的方式确实是否登录以及完成注销机制的设计。发送的URL、发送名称的请求参数和发送密码的请求参数都是固定不变的。</p>
<p>除了BASIC和FORM之外，还可以设置DIGEST（摘要验证，在网络上传输的是密码的MD5值）和CLIENT-CERT（采用证书的安全机制）</p>
<p>web应用程序采用HTTP over SSL是比较安全的方式，也就是HTTPS，在web.xml中的<security-constraint>设置</security-constraint></p>
<pre><code>&lt;user-data-constraint&gt;
    &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
&lt;/user-data-constraint&gt;
</code></pre><p><transport-guarantee>的默认值是NONE，还可以设置为CONFIDENTIAL（机密性），INTEGRAL（完整性），两个效果都是一样的</transport-guarantee></p>
<p>request.isUserInRole方法可以判断登录用户的角色。</p>
<h1 id="整合数据库"><a href="#整合数据库" class="headerlink" title="整合数据库"></a>整合数据库</h1><ol>
<li>加载JDBC驱动程序：通过java.lang.Class类的forName，动态加载驱动程序类，Class.forName(“com.mysql.jdbc.Driver”)，不同的数据加载不同的类。</li>
<li>提供JDBC URL，JDBC URL定义了连接数据库时的协议等标识。。jdbc：mysql:://主机名称：连接端口/数据库名称？参数=值&amp;参数=值，参数包括用户名、密码、useUnicode（是否使用unicode）、character-Encoding（字符编码方式），<strong>xml文件中不能出现“&amp;”，所以用“&amp;amp；”代替</strong>。</li>
<li>取得Connection实例：coon=DriverManager.getConnection（url），url是第二部里面的URL；当数据库管理人员不想告诉开发人员数据库的密码和用户名时，开发者可以通过JNDI的方式获得Connection</li>
</ol>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ol>
<li>Template Method模式（Gof设计模式）：父类会定义服务流程的方法，子类继承或者覆写实现具体的流程。</li>
<li>Intercepting Filter模式（Java EE设计模式）：过滤器</li>
<li>Model-View-Controller模式（架构模式）：MVC以及Model 2 模式</li>
<li>Business Delegate模式： Business Delegate是中间件，它接收到请求之后交给其他部分处理并由其他部分返回结果，降低耦合度。</li>
<li>Service Locator模式：类似于前一个，隐藏复杂的操作。</li>
<li>Transfer Object模式：可以把一些信息封装在某个类中，传输类，比如说图书管理系统里的图书类或者用户类。</li>
<li>Front Controller模式：FrontController负责了集中管理所有与请求相关的动作，处理完毕之后委托给其他对象（不建议）</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看到今天，这本Servlet与Jsp终于看完了，java web的路线还有spring、struts和MyBatis，Hibernate，这几个准备在暑假看看有没有实战的项目，设计模式现在不准备深入研究，只是先通过项目学习一下。以后也不一定就一定搞这个，但是干一行精一行还是很有必要地~~~~下次准备把一本书的内容都写在一起，每周分开就好了，之前这本书看的太乱，大概写了十几个md文件。</p>
<hr>
<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><ol>
<li>从raw_input()读取的内容永远以字符串的形式返回。</li>
<li>list是可变列表，tuple是不变元组，变不变指的是内存指向。</li>
<li>dict相当于其他语言里的map，python里面在交互式命令行模式下当返回None的时候不显示结果。dict里的key是不可变对象。</li>
<li>set是集合，没有重复元素。可以重复添加，但没有效果。两个集合可以利用“&amp;“和”|“做数学意义上的交集和并集。</li>
<li>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</li>
<li><p>python里面函数不需要写明返回值的类型，可以返回多个值，但实际上仍然是一个tuple。函数的默认参数写在定义函数的地方。</p>
<p> def enroll(name, gender, age=6, city=’Beijing’):</p>
<pre><code>enroll(&apos;Sarah&apos;, &apos;F&apos;) 
enroll(&apos;Bob&apos;, &apos;M&apos;, 7)
enroll(&apos;Adam&apos;, &apos;M&apos;, city=&apos;Tianjin&apos;)`
</code></pre></li>
</ol>
<ol>
<li>默认参数必须指向不变对象。</li>
<li><p>可变参数传入函数的时候会自动组装成一个tuple.</p>
<p> def calc(*numbers):</p>
<pre><code>sum=0
for n in numbers
    sum=sum+n*n
return sum
</code></pre></li>
<li><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
</li>
<li><p>关键字参数有什么用？它可以扩展函数的功能。</p>
<p>def person(name,age,**kw): #kw是关键字参数</p>
</li>
<li><p>参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。</p>
</li>
<li>尾递归是指在函数返回的时候，调用自身本身，并且，return语句不能包含表达式，理论上可以防止栈溢出，但是Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</li>
<li>字符串、元组、列表切片[起始元素:终止元素:步长]，步长省略时为1，起始元素从0开始，不包括终止元素。</li>
<li>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()</li>
<li>如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断，isinstance(‘abc’, Iterable) # str是否可迭代</li>
<li><p>列表生成式 [要生成的元素 for 迭代元素 in 迭代的集合或者列表等等一切可以迭代的东西)]</p>
<p>>&gt;&gt;L=[x*x for x in range(10)]<br>>&gt;&gt;L<br>[0,1,4,9,16,25,36,49,64,81]</p>
</li>
<li><p>创建一个generator，只要把一个列表生成式的[]改成()，就创建了一个generator，通过for循环迭代所有的内容。</p>
</li>
<li>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。</li>
<li>函数名也是变量，函数名也可以赋值给其他变量，一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong>高阶函数</strong>。</li>
<li>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。</li>
<li>reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</li>
<li>字典的定义是用大花括号{}，集合set的输出结果中[]并不代表是列表。</li>
<li>Python内建的filter()函数用于过滤序列。filter()接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</li>
<li>通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1。</li>
<li>sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</li>
<li>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</li>
<li>在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为<strong>“闭包（Closure）”</strong>的程序结构拥有极大的威力。<strong>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。</li>
<li>关键字lambda表示匿名函数，冒号前面的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。匿名函数也是函数。</li>
<li>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</li>
<li>把@log放到now()函数的定义处，相当于执行了语句：now = log(now)</li>
<li>functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单.</li>
<li>每一个包目录下面都会有一个<strong>init</strong>.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<strong>init</strong>.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块。</li>
</ol>
<hr>
<p>今天决定python只学习自己需要的部分，所以不准备所有都看了，之前看的一些高级特性都没搞明白。</p>
<ol>
<li><p>当我们在命令行运行模块文件时，Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该模块时，if判断将失败。</p>
<p> if <strong>name</strong>=’<strong>main</strong>‘:</p>
<pre><code>test()
</code></pre></li>
<li><p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public，类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。</p>
</li>
<li><p>安装第三方库的时候使用“pip install  模块名” 。</p>
</li>
<li><p>定义类，<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身</p>
<p> class Student(object):</p>
<p> def <strong>init</strong>(self,name,score):</p>
<pre><code>self.name=name
self.score=score
</code></pre></li>
<li><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。</p>
</li>
<li>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</li>
<li>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</li>
<li>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。Python内置的logging模块可以非常容易地记录错误信息。</li>
<li>可以捕获错误之后打印错误又把错误抛出，因为当前函数可能不能处理，raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型。 </li>
<li>调试的方法有以下几种：用print发现错误的地方、用assert发现错误的地方、用logging记录错误的地方、启动Python的调试器pdb。</li>
<li>pdb.set_trace()是用来调试比较简单的部分，只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行。</li>
<li>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符。文件对象必须close，但是“with open(‘/path/to/file’, ‘r’) as f：  ”，使用前面这种方式打开就不必调用f.close()方法，<strong>调用read()会一次性读取文件的全部内容，可以反复调用read(size)方法，每次最多读取size个字节的内容。调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list</strong>。</li>
<li>要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可。</li>
<li>multiprocessing模块提供了一个Process类来代表一个进程对象，创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动。</li>
<li>如果要启动大量的子进程，可以用进程池的方式批量创建子进程。</li>
<li>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行。</li>
<li>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，<strong>多线程需要考虑同步的问题。</strong></li>
<li>线程同步的时候需要用到lock， lock.acquire()， lock.release()，当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。用try…finally来确保锁一定会被释放。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/11/20180116/" data-id="cjf28yp8i000zw8hutj8aa8l8" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/servlet/">servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20180108" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/08/20180108/" class="article-date">
  <time datetime="2018-01-08T00:55:12.000Z" itemprop="datePublished">2018-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/08/20180108/">20180108</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>周六晚上熬夜到四点，导致周日没睡好，周日晚上也没睡好，因为周一要去实验室，上一周忙着考试，所以没学什么知识，这周虽然有个很扯的活要干，但是好歹有自己的时间，虽然现在还是很困。</p>
<p>现在在学的部分是jsp中的JSTL，主要作用是来替换JSP页面中的scriptlet。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p> 之前所有的异常都是设置专用的错误网页，将出现的错误转发到其他页面进行处理展示，如果要在发生异常的网页捕捉异常，JSTL的标签&lt;c:catch&gt;标签捕捉本网页的异常对象，使用&lt;c:catch&gt;将可能产生异常的网页段落包起来，如果真的发生了异常，会把异常对象设置给&lt;c:catch&gt;里面的var属性所指定的名称，异常都是Throwable的子类，都拥有getMessage（）的方法。</p>
<hr>
<p>导入JSP网页到目前网页的方式：1. 通过include指示元素可以直接将两个JSP网页直接拼接在一起，2. <a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>标签可在运行时期依条件动态决定是否包括另一个网页。</p>
<pre><code>&lt;isp:include page=&quot;Xxx.jsp&quot;&gt;
    &lt;jsp:param name=&quot;a &quot; value=&quot;c &quot;&gt;
    &lt;jsp:param name=&quot;b&quot;  value=&quot;d&quot;&gt;
&lt;/jsp:include&gt;
</code></pre><p>在JSTL中有&lt;c:import&gt;标签，搭配&lt;c:param&gt;在导入另一网页时带有参数</p>
<pre><code>&lt;c:import url=&quot;Xxx.jsp&quot;&gt;
    &lt;c:param name=&quot;a&quot; value=&quot;c&quot;&gt;
    &lt;c:param name=&quot;a&quot; value=&quot;c&quot;&gt;
&lt;/c:import&gt;
</code></pre><p>这个标签也可以导入非目前web程序中的网页</p>
<hr>
<p>\<a href="jsp:setProperty\" target="_blank" rel="noopener">jsp:setProperty\</a>  只能用来设置JavaBean的属性，设置其他的值需要使用&lt;c:set&gt;，set中的scope属性用来设置范围，var属性是变量名，value是值</p>
<pre><code>&lt;c:set var=&quot;login&quot; value=&quot;${user.name}&quot; scope=&quot;session&quot;/&gt;
&lt;c:set var=&quot;details&quot; scope=&quot;session&quot;&gt;
    caterpillar,openhone
&lt;/c:set&gt;
</code></pre><p>&lt;c:set&gt; 里面没有指定属性的时候，会从page、request、session、application的范围寻找属性名称，找到就在该范围内设置，都没找到就在page范围内设置，移除属性可以使用&lt;c:remove&gt;,&lt;c:set&gt;还可以用来设置JavaBean的属性或者是Map对象的键值，必须使用target属性进行设置。</p>
<hr>
<p>&lt;c:out&gt;可以输出指定的文字，value属性需要设置成想要输出的文字。&lt;c:out&gt;会自动替代里面出现的可能在HTML中的字符，EL运算结果为null时，不会显示任何值，但如果想要显示默认值，不需要检查是否为空，可以直接 &lt; c : out value=”${param.a}” default=”0”/&gt; </p>
<hr>
<p>response的encodeURL用作URL重写，以在用户关闭Cookie功能时，仍然可以继续利用URL重写来维持使用session进行会话管理，如果不想使用scriptlet编写response的encodeURL，则可以使用JSTL的&lt;c:url&gt;，它会在用户关闭Cookie功能的时候，自动用SessionID作URL重写，标签里可以加上&lt;c:param&gt;</p>
<h1 id="Tag-File自定义标签（tag文件）"><a href="#Tag-File自定义标签（tag文件）" class="headerlink" title="Tag File自定义标签（tag文件）"></a>Tag File自定义标签（tag文件）</h1><p>如果有现成且通用的自定义标签库，不需要重复造轮子。</p>
<p>使用自定义的tag标签，需要新建扩展名为tag的文件，并放在WEB-INF/tags下面，把tag的定义写在扩展名为tag的文件中，开始的时候需要用tag指示元素说明信息，在需要使用这个tag的JSP页面中，可以使用taglib指示元素的prefix定义前置名称，以及使用tagdir属性定义tag file的位置（tagdir只能指定/WEB-INF/tags的子文件夹），然后就可以在想要使用的地方写上prefix+tag文件名。这里存在的一个问题就是tag的定义文件里如果使用了一些与应用程序相关的过程，就很难移植。</p>
<p>几个网页只有细微差别，可以写成一个Tag File，通过attribute设置不同的部分，在使用的地方的标签里通过为attribute赋值更改。Tag File也可以有主体内容，在<body>和</body>之间使用<a href="jsp:doBody/" target="_blank" rel="noopener">jsp:doBody/</a>，这个标签可以取得使用Tag File标签时的主体内容，这个主体内容指的就是在使用标签的时候自定义的标签头和标签尾之间的内容。</p>
<p><strong>Tag File 的标签在使用时有主体，默认是不允许有Scriplet，因为定义Tag File的时候tag指示元素的body-content属性默认就是scriptless</strong>，body-content属性的值还可以是empty和tagdependent，empty表示一定没有主体内容，tagdependent表示将主体中的内容当做纯文本输出。</p>
<p>要将tag File文件压缩成jar文件必须把tag文件封装在jar文件的META-INF/tags下，META-INF/TLDS下定义tld文件，生成的jar包放在WEB-INF/lib文件夹中就可以使用了。</p>
<p><strong>尽量不要在Tag File中编写Scriptlet来操作Java对象</strong></p>
<h1 id="Simple-Tag自定义标签（java自定义类）"><a href="#Simple-Tag自定义标签（java自定义类）" class="headerlink" title="Simple Tag自定义标签（java自定义类）"></a>Simple Tag自定义标签（java自定义类）</h1><p>如果自定义标签时需要操作Java对象，可以考虑实现Simple Tag来自定义标签，将Java程序代码写在其中。</p>
<ol>
<li>编写标签处理器，继承SimpleTagSupport来实现标签处理器，并重写doTag()方法进行标签处理，getJspBody()方法会返回一个JSPFragment对象，代表两个标签之间的主体内容，调用JSPFragment的invoke方法并传入一个null，表示运行标签之间的主体内容(null表示将使用PageContext取得默认的JSPWriter对象作为输出响应，也就是默认会输出到浏览器，可以把最后的结果传入其他的Writer，最后要输出的时候可以通过PageContext的getOut取得JspWriter对象。而后调用print（）方法输出结果)。在标签处理器定义的过程中需要把属性定义成类变量，在tld文件中声明之后就可以直接在使用的时候赋值。</li>
<li>为了让web容器了解标签和标签处理期之间的关系，需要写一个tld文件。一个tls文件中可以声明很多个tag </li>
</ol>
<pre><code>&lt;taglib&gt;
&lt;tlib-version&gt;库的版本号&lt;/tlib-version&gt;
&lt;short-name&gt;自定义标签的前缀&lt;/short-name&gt;
&lt;uri&gt;http://openhome.cc/jstl/fake（自定义标签的链接）&lt;/uri&gt;
&lt;tag&gt;
    &lt;name&gt;自定义标签名称&lt;/name&gt;
    &lt;tag-class&gt;实现标签的处理的类的绝对路径（包名.类名）&lt;/tag-class&gt;
    &lt;body-content&gt;scriptless&lt;/body-content&gt;
    &lt;attribute&gt;
        &lt;name&gt;标签上属性的名称&lt;/name&gt;
        &lt;required&gt;是否一定要设置这个属性（true/false）&lt;/required&gt;
        &lt;rtexprvalue&gt;属性是否接受运行时期运算的结果&lt;/rtexprvalue&gt;
        &lt;type&gt;属性的类型（Boolean之类的）&lt;/type&gt;
    &lt;/attribute&gt;
&lt;/tag&gt;
&lt;/taglib&gt;
使用的时候利用指示元素taglib指明prefix为前缀，URI为tld文件里的URI。
</code></pre><p>每一次请求都会创建新的标签处理器实例，执行完doTag（）之后就销毁实例，在dotag过程中需要中断输出或者处理的话可以抛出SkipPageException</p>
<h3 id="与父标签的沟通"><a href="#与父标签的沟通" class="headerlink" title="与父标签的沟通"></a>与父标签的沟通</h3><p>标签之间的嵌套只能使用与父标签的沟通机制。书中的例子是自定义类似于&lt; c: choose &gt;和&lt; c : when &gt;、&lt; c : otherwise &gt;这种父标签和子标签的关系，&lt; c: choose &gt;作为最外层的标签，定义中有一个Boolean类型的matched变量，在when标签的定义过程中，需要设置当when标签的父标签不是choose标签的时候发生错误，其次如果父标签的metched变量为true，说明之前有when标签通过测试，matched变量就是为了表示内部的标签是否存在匹配成功的现象。when标签的定义过程中对test变量，也就是when标签中的test属性验证成功，就需要将when的父标签的matched变量设置成true，otherwise标签和when标签很类似，只不过otherwise标签没有test属性，直接执行jsp就可以了，<strong>tld文件的主要作用就是告诉web容器标签名称和我们自定义标签类的对应关系</strong>，如果某一个标签外层有很多标签，要获得指定类型的外层标签，可以通过SimpleTagSupport的findAncestorWithClass（）静态方法，会在外层标签中寻找，直到找到指定类型的外层标签对象后返回。</p>
<h1 id="Tag自定义标签（java自定义类）"><a href="#Tag自定义标签（java自定义类）" class="headerlink" title="Tag自定义标签（java自定义类）"></a>Tag自定义标签（java自定义类）</h1><p>大多数情况下simple Tag能满足自定义标签的需求，然而Simple Tag是从jsp2.0之后才出现的，了解一下Jsp2.0之前的自定义标签</p>
<p>和之前的差别在于继承的类不一样，继承的父类是TagSupport，调用的函数是doStartTag（）方法，该方法的返回值决定是否执行主体内容，Tag实例是可以重复使用的。所以要注意对象状态是否会保留下来，doStartTag（）方法可以进行状态重置的动作，release方法不能用来状态重置，因为release（）方法只会在标签实例真正被销毁回收，</p>
<p>doStartTag()可以返回EVAL_BODY_INCLUDE（执行主体内容）或者SKIP_BODY（执行doEndTag方法），然后调用doAfterBody方法，返回值是EVAL_BODY_AGAIN（再次执行主体内容，然后调用doAfterBody方法，）或者SKIP_BODY（doEndTag方法），doEndTag方法的返回值是EVAL_PAGE（执行后续页面）或者SKIP_PAGE（直接结束）。上面的三个方法都有默认返回值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/08/20180108/" data-id="cjf28yp8g000uw8hujnkxdtal" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017122702" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/27/2017122702/" class="article-date">
  <time datetime="2017-12-27T01:54:40.000Z" itemprop="datePublished">2017-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/27/2017122702/">2017122702</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><p>JSTL（JavaServer Pages Standard Tag Library）来替换JSP页面中用来实现页面逻辑的scriptlet。</p>
<p>提供的标签库可以分为五类，核心标签库、格式标签库、SQL标签库、XML标签库、函数标签库。</p>
<p>要使用JSTL标签库，必须在网页上使用taglib指示元素定义前置名称与uri引用，JSTL的jar包需要手动添加到项目的WEB-INF/lib文件夹中，惯例上使用JSTL核心标签库的时候，会使用c作为前置名称，URI引用则告知容器如何引用JSTL标签库实现。</p>
<pre><code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; 
</code></pre><p>&lt;c:if&gt;就相当于java中一个单一的if语句</p>
<p>&lt;c:choose&gt;、&lt;c:otherwise&gt;、&lt;c:when&gt;搭配使用就相当于java中ifelse语句以及该语句的嵌套</p>
<p>&lt;c:foreach&gt;就是轮询某个集合或者数组，里面的var属性就是轮询变量，items就是数组或者Collection变量</p>
<p>&lt;c:fortoken&gt;的主要作用就是为了将字符串按照指定的分隔符分为多个字符串，var属性表示轮询变量，delims表示分隔符，items仍然表示字符串。</p>
<h2 id="错误处理标签"><a href="#错误处理标签" class="headerlink" title="错误处理标签"></a>错误处理标签</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/27/2017122702/" data-id="cjf28yp8h000ww8humpaigbyr" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-20171227" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/27/20171227/" class="article-date">
  <time datetime="2017-12-27T01:06:34.000Z" itemprop="datePublished">2017-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/27/20171227/">20171227</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="表达式语言（EL）"><a href="#表达式语言（EL）" class="headerlink" title="表达式语言（EL）"></a>表达式语言（EL）</h1><p>替换掉scriptlet编写的属性、请求参数、标头与cookie等信息的获取，或者是一些简单的运算和判断</p>
<p>EL是使用${与}来包括所要进行处理的表达式，EL会自行进行类型转换</p>
<p>可以在page指示元素的isELIgnored属性（默认为true），来设置jsp网页是否使用EL，原因是因为网页中已经使用了EL类似的语法功能，也可以在web.xml中设置<el-ignored>标签为true，不使用EL。两种方式以前者为主</el-ignored></p>
<p>EL的应用实例</p>
<pre><code>&lt;h1&gt;${user.name}&lt;/h1&gt;&lt;%--按照page、request、session、application
的顺序来寻找EL中指定的属性&gt;--%
&lt;h1&gt;${user[&quot;name&quot;]}&lt;/h1&gt;&lt;%--和上面的效果相同--%&gt;
</code></pre><p>如果数组元素被设置的索引为array，setAttribute（索引，内容），List也可以使用下面的方法访问。</p>
<pre><code>${array[0]}&lt;%--第一个元素--%&gt;
${array[1]}&lt;%--第二个元素--%&gt;
${array[2]}&lt;%--第三个元素--%&gt;
</code></pre><ol>
<li>点运算符左边可以是JavaBean或者Map对象</li>
<li>如果使用[]运算符，则左边可以是JavaBean、Map、数组或者List对象</li>
</ol>
<p>当左边是map对象的时候，推荐使用[]运算符，因为map对象的key有可能是空白或者带有点运算符的，取值的时候两个点运算符在一起会引起错误。[]运算符内部可以进行嵌套</p>
<pre><code>${login[&quot;user name&quot;]}
${login[&quot;pass.word&quot;]}
</code></pre><h2 id="EL隐含对象"><a href="#EL隐含对象" class="headerlink" title="EL隐含对象"></a>EL隐含对象</h2><p>11个隐含对象，pageContext对应PageContext，其他的隐含对象都对应Map类型。</p>
<ol>
<li>pageContext：PageContext本身就是JavaBean</li>
<li>与属性相关的隐含对象</li>
<li>与请求参数相关的隐含对象： param与paranValues，param可以取得某个参数的值，paramValues可以取得所有请求参数，返回值是数组</li>
<li>与标头（header）相关的隐含对象：header或者headerValues</li>
<li>cookie隐含对象：取得用户设置的cookie值</li>
<li>初始参数隐含对象：initParam可以用来取得web.xml中设置的ServletContext初始参数。</li>
</ol>
<h2 id="EL运算符"><a href="#EL运算符" class="headerlink" title="EL运算符"></a>EL运算符</h2><p>%和mod都是求余运算符，关系运算符都有相应的符号和英文简称，比如&lt;以及lt（less than）、&gt;与gt（greater than）、!=与ne（not equal）</p>
<h2 id="自定义EL函数"><a href="#自定义EL函数" class="headerlink" title="自定义EL函数"></a>自定义EL函数</h2><p>第一步：编写类，这个类必须是公开类，想调用的方法必须是公开的且为静态方法。第二步：web容器必须知道如何将这个类中的方法当作EL函数使用，必须编写一个标签链接库描述文件（TLD）文件，tld文件中需要指明自定义的函数名称，对应到的类和对应到的那个类的具体方法，以及特定的URI，使用的jsp中&lt;%@taglib uri=””  prefix=””%&gt;uri是为了能够快速找到tld文件，prefix的作用是为了避免当jsp中有多个来自不同设计者的EL自定义函数会出现名称冲突。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/27/20171227/" data-id="cjf28yp8d000pw8hucjqo0uq8" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20171226" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/26/20171226/" class="article-date">
  <time datetime="2017-12-26T01:54:40.000Z" itemprop="datePublished">2017-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/26/20171226/">20171226</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>JSP和Servlet是一体两面，jsp最后还是会被容器转译为Servlet，自动编译成.class文件，载入.class文件然后生成Servlet对象。JSP出错的时候可以查看Servlet代码发现错误</p>
<p>不同的web容器对于JSP的转译方式是不同的，jsp转变成Servlet之后会调用_jspInit()，_jspdestroy()。一般情况下不会重写这些函数，如果想要在jsp初始化的时候做一些事情，可以选择重写JSPInit（）和jspDestroy（）。</p>
<h2 id="指示元素"><a href="#指示元素" class="headerlink" title="指示元素"></a>指示元素</h2><p>&lt;%@ 指示类型  [属性=“值”] <em> %&gt;（[属性=“值”] </em>是正则表达式）</p>
<p>常用的指示类型：page（告知容器如何转译目前的jsp网页）、include（将其他的jsp页面包括进来进行转译）、taglib（告知容器如何转译这个页面中的标签库）</p>
<p>include将其他页面包含的时候是一种静态的包含方式，就是把包含的文件直接拼接在一起。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>在&lt;%!与%&gt;之间声明的程序代码，都将转译为Servlet中的类成员或者方法。也就是说把<strong>所有的成员变量声明和方法声明的java代码</strong>都写在这个&lt;%!与%&gt;之间，容器会使用同一个Servlet来服务不同用户的请求，每个请求就是一个线程，声明 变量的时候必须小心数据共享与线程安全的问题，使用该方法声明的变量是类成员变量，JSPInit（）和JSPDestroy（）就需要使用这种方式重写。</p>
<h2 id="Scriptlet元素"><a href="#Scriptlet元素" class="headerlink" title="Scriptlet元素"></a>Scriptlet元素</h2><p>&lt;%  java语句  %&gt;所有的内容将被转译到Servlet源代码中的_JSPService（），可以利用java语句的注释方式进行注释（//或者/<em>········</em>/)</p>
<h2 id="表达式元素"><a href="#表达式元素" class="headerlink" title="表达式元素"></a>表达式元素</h2><p>&lt;%= java 表达式&gt;表达式元素不用加分号，表达式元素中的表达式会直接转译成out对象输出时的指定内容。</p>
<p>因此在jsp中输出&lt;%或者%&gt;符号，要将角括号置换为替代字符，&lt;%可以换成&lt;%  ，%&gt; 可以换成%&gt;或者%>。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>JSP有自己专用的注释，即&lt;%–与–%&gt;，容器在转译JSP到Servlet的时候，会忽略两者之间包括的文字。</p>
<hr>
<p>Scriptlet中的一些类似于out和request的对象，转译成Servlet之后会对应到Servlet中的某个对象，request对应HttpServletRequest，像request和out的对象就被称为隐含对象。</p>
<p>pageContext转译后对应PageContext对象，提供了jsp页面资源的封装，page对应this</p>
<p>out并不直接对应于有HttpServletResponse得到的PrintWriter对象，out对应JSPWriter对象，该对象模拟了BufferedWriter与PrintWriter的功能。jspWriter具有缓冲区功能，这时候就决定于页面是否具有缓冲区的功能了，如果没有则会立即输出，有的话只有在清空缓冲区才会输出，page指示元素的buffer属性设置缓冲区的大小，满了之后的行为采用autoFlush属性决定。</p>
<p>可以通过PageContext获得所有的隐含对象，除了封装所有的jsp页面信息之外 ，还可以使用pageContext来设置页面范围属性setAttribute、getAttribute、removeAttribute</p>
<p>在jsp页面中设置属性的方式有两种，一种是通过pageContext获得HttpServletRequest、ServletContext、HttpSession，另一种是利用pageContext统一提供的接口。getAttribute（String name，int Scope），setAttribute（String name，Object value,int scope）,remove(String name, int scope)，Scope是标识不同的范围，pageContext提供了findAttribute（），从页面，请求，会话到应用程序范围以此寻找。</p>
<h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><p>使用page指示元素，设置errorPage属性便可以指定错误处理的JSP页面。错误页面的page指示元素的isErrorPage属性设置为true。</p>
<h2 id="标准标签"><a href="#标准标签" class="headerlink" title="标准标签"></a>标准标签</h2><p>主要作用是减少scriptlet的使用，include指示元素可以把另一个JSP页面包含进来转移成一个Servlet类，无法在运行时动态调整想要的页面。如果想要在运行时依条件动态调整想要包括的JSP页面，则可以使用&lt;jsp：include&gt;标签，可以动态包括要给该页面的请求参数</p>
<p>转发页面可以使用&lt;jsp：forward&gt;，与前者的使用方法相同。</p>
<pre><code>&lt;jsp:forward page=&apos;&quot;add.jsp&quot;&gt;
    &lt;jsp:param name=&quot;a&quot; value=&quot;1&quot;&gt;
    &lt;jsp:param name=&quot;a&quot; value=&quot;2&quot;&gt;
&lt;/jsp:forward&gt;
</code></pre><p><strong><a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>、<a href="jsp:setProperty" target="_blank" rel="noopener">jsp:setProperty</a>、<a href="jsp:getProperty" target="_blank" rel="noopener">jsp:getProperty</a></strong></p>
<p>JavaBean指的是满足以下条件的java对象，必须实现了Java.io.Serializable接口，没有公开的类变量，具有无参数的构造函数，具有公开的设值方法和取值方法，setter和getter，可以直接使用标签在页面中赋值</p>
<pre><code>&lt;jsp:useBean id=&quot;名称（类实例变量名称）&quot; class=&quot;包名.类名&quot; 
scope=&quot;page、request、session、application&quot;
type=&quot;想要指定的类型&quot;/&gt;
&lt;jsp:setProperty name=&quot;类实例变量名&quot; property=&quot;属性值&quot;/&gt;
</code></pre><p>setProperty标签的property为“*”时，表示将自动寻找符合JavaBean中设值方法名称的请求参数值，如果请求参数的名称为xxx，就将请求参数值使用setXxx（）方法设置给JavaBean实例。</p>
<p>在jsp中就可以写直接 调用id.方法（），赋值可以直接写&lt;jsp:getProperty name=”变量名” property=”属性名”&gt;</p>
<p>赋值的时候可以通过&lt;jsp:setProperty name=”user” property=”password” value=”123456”/&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/26/20171226/" data-id="cjf28yp8e000sw8hu36ee4gwd" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Suivant &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Struts/">Struts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jsp/">jsp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台/">后台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Struts/" style="font-size: 12px;">Struts</a> <a href="/tags/java/" style="font-size: 16px;">java</a> <a href="/tags/jsp/" style="font-size: 16px;">jsp</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/后台/" style="font-size: 14px;">后台</a> <a href="/tags/数据库/" style="font-size: 18px;">数据库</a> <a href="/tags/笔记/" style="font-size: 20px;">笔记</a> <a href="/tags/随笔/" style="font-size: 14px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/22/markdown语法/">markdown语法</a>
          </li>
        
          <li>
            <a href="/2018/03/22/20171110/">20171110</a>
          </li>
        
          <li>
            <a href="/2018/03/19/20180319 struts/">20180319</a>
          </li>
        
          <li>
            <a href="/2018/03/13/20180313 struts/">20180313</a>
          </li>
        
          <li>
            <a href="/2018/01/18/JavaEE/">JavaEE</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Propulsé par <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>